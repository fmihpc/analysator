

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>analysator.vlsvfile.vlsvreader &mdash; analysator  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=187304be"></script>
      <script src="../../../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../../../about/" />
    <link rel="index" title="Index" href="../../../../genindex/" />
    <link rel="search" title="Search" href="../../../../search/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../" class="icon icon-home">
            analysator
              <img src="../../../../_static/logo_color.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../analysator/">Introduction to Analysator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../analysator_exercises/">Analysator exercises</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../analysator_supported/">Analysator supported data reducers and vlasiator variables</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Analysator reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../plot/">plot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../calculations/">calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../vlsvfile/">vlsvfile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../miscellaneous/">miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../scripts/">scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contribution guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribution_code/">Contributing code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribution_doc/">Contributing to documentation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../about/">Credits</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../">analysator</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../">analysator</a></li>
      <li class="breadcrumb-item active">analysator.vlsvfile.vlsvreader</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for analysator.vlsvfile.vlsvreader</h1><div class="highlight"><pre>
<span></span><span class="c1">#s </span>
<span class="c1"># This file is part of Analysator.</span>
<span class="c1"># Copyright 2013-2016 Finnish Meteorological Institute</span>
<span class="c1"># Copyright 2017-2024 University of Helsinki</span>
<span class="c1"># </span>
<span class="c1"># For details of usage, see the COPYING file and read the &quot;Rules of the Road&quot;</span>
<span class="c1"># at http://www.physics.helsinki.fi/vlasiator/</span>
<span class="c1"># </span>
<span class="c1"># This program is free software; you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation; either version 2 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1"># </span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1"># </span>
<span class="c1"># You should have received a copy of the GNU General Public License along</span>
<span class="c1"># with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="c1"># 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="c1"># </span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">struct</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xml.etree.ElementTree</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ET</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ast</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numbers</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">vlsvvariables</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.reduction</span><span class="w"> </span><span class="kn">import</span> <span class="n">datareducers</span><span class="p">,</span><span class="n">multipopdatareducers</span><span class="p">,</span><span class="n">data_operators</span><span class="p">,</span><span class="n">v5reducers</span><span class="p">,</span><span class="n">multipopv5reducers</span><span class="p">,</span><span class="n">deprecated_datareducers</span>
<span class="k">try</span><span class="p">:</span>
   <span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
   <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.vlsvwriter</span><span class="w"> </span><span class="kn">import</span> <span class="n">VlsvWriter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..calculations.variable</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_data</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..calculations.interpolator_amr</span><span class="w"> </span><span class="kn">import</span> <span class="n">AMRInterpolator</span><span class="p">,</span> <span class="n">supported_amr_interpolators</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">operator</span><span class="w"> </span><span class="kn">import</span> <span class="n">itemgetter</span>


<span class="n">interp_method_aliases</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;trilinear&quot;</span><span class="p">:</span><span class="s2">&quot;linear&quot;</span><span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">PicklableFile</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">fileobj</span> <span class="o">=</span> <span class="n">fileobj</span>

   <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
      <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;_file_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileobj</span><span class="o">.</span><span class="n">name</span>
      <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;_file_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileobj</span><span class="o">.</span><span class="n">mode</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileobj</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
         <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;_file_pos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;_file_pos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileobj</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
      <span class="k">del</span> <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;fileobj&#39;</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">ret</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;_file_name&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;_file_mode&#39;</span><span class="p">])</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">fileobj</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;_file_pos&#39;</span><span class="p">])</span>
      <span class="k">del</span> <span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;_file_name&#39;</span><span class="p">]</span>
      <span class="k">del</span> <span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;_file_mode&#39;</span><span class="p">]</span>
      <span class="k">del</span> <span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;_file_pos&#39;</span><span class="p">]</span>
      <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">dict_keys_exist</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">query_keys</span><span class="p">,</span> <span class="n">prune_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
   <span class="k">if</span> <span class="n">query_keys</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
   <span class="c1"># this helps quite a lot... for some cases.</span>
   <span class="k">if</span> <span class="n">prune_unique</span><span class="p">:</span>
      <span class="n">unique_keys</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">query_keys</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

      <span class="c1"># these are all about the same...</span>
      <span class="c1"># if (unique_keys.ndim == 1):</span>
      <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">unique_keys</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
      <span class="c1"># else: # and this isn&#39;t worth it?</span>
      <span class="c1">#    mask = np.array([tuple(k) in dictionary.keys() for k in unique_keys],dtype=bool)</span>

      <span class="c1"># mask = np.empty(query_keys.shape, dtype=bool)</span>
      <span class="c1"># for i,k in enumerate(query_keys):</span>
      <span class="c1">#    mask[i] = [k in dictionary.keys() for k in query_keys],dtype=bool)</span>

      <span class="c1"># mask = np.array(list(map(lambda c: c in dictionary.keys(),query_keys)), dtype=bool)</span>

      <span class="c1"># dlambda = np.frompyfunc(lambda c: c in dictionary.keys(),1,1)</span>
      <span class="c1"># mask = np.array(dlambda(query_keys),dtype=bool)</span>
      <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">query_keys</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

   <span class="k">return</span> <span class="n">mask</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fsGlobalIdToGlobalIndex</span><span class="p">(</span><span class="n">globalids</span><span class="p">,</span> <span class="n">bbox</span><span class="p">):</span>
   <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">globalids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

   <span class="n">stride</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
      <span class="n">indices</span><span class="p">[:,</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">globalids</span> <span class="o">//</span> <span class="n">stride</span><span class="p">)</span> <span class="o">%</span> <span class="n">bbox</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
      <span class="n">stride</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

   <span class="k">return</span> <span class="n">indices</span>

<span class="c1"># Read in the global ids and indices for FsGrid cells, returns</span>
<span class="c1"># min and max corners of the fsGrid chunk by rank</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fsReadGlobalIdsPerRank</span><span class="p">(</span><span class="n">reader</span><span class="p">):</span>
   <span class="n">numWritingRanks</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;numWritingRanks&quot;</span><span class="p">)</span>
   <span class="n">rawData</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;fsgrid&quot;</span><span class="p">)</span>
   <span class="n">bbox</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_BBOX&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;fsgrid&quot;</span><span class="p">)</span>
   <span class="n">sizes</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_DOMAIN_SIZES&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;fsgrid&quot;</span><span class="p">)</span>

   <span class="n">currentOffset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="n">rankIds</span> <span class="o">=</span> <span class="p">{}</span>
   <span class="n">rankIndices</span> <span class="o">=</span> <span class="p">{}</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">numWritingRanks</span><span class="p">):</span>
      <span class="n">taskIds</span> <span class="o">=</span> <span class="n">rawData</span><span class="p">[</span><span class="n">currentOffset</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">currentOffset</span><span class="o">+</span><span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span>
      <span class="n">rankIds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">taskIds</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">taskIds</span><span class="p">)])</span>
      <span class="n">rankIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsGlobalIdToGlobalIndex</span><span class="p">(</span><span class="n">rankIds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bbox</span><span class="p">)</span>
      <span class="n">currentOffset</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
      
   <span class="k">return</span> <span class="n">rankIds</span><span class="p">,</span> <span class="n">rankIndices</span>

<span class="c1"># Read global ID bboxes per rank and figure out the decomposition from</span>
<span class="c1"># the number of unique corner coordinates per dimension</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fsDecompositionFromGlobalIds</span><span class="p">(</span><span class="n">reader</span><span class="p">):</span>
   <span class="n">ids</span><span class="p">,</span> <span class="n">inds</span> <span class="o">=</span> <span class="n">fsReadGlobalIdsPerRank</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
   <span class="n">lows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inds</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
   <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lows</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
   <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lows</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
   <span class="n">zs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lows</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
   <span class="k">return</span> <span class="p">[</span><span class="n">xs</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">ys</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">zs</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">map_vg_onto_fg_loop</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">vg_cellids</span><span class="p">,</span> <span class="n">refined_ids_start</span><span class="p">,</span> <span class="n">refined_ids_end</span><span class="p">):</span>
   <span class="c1">#arr = np.zeros(sz, dtype=np.int64) + 1000000000 # big number to catch errors in the latter code, 0 is not good for that</span>

   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vg_cellids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">refined_ids_start</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]:</span><span class="n">refined_ids_end</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                           <span class="n">refined_ids_start</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span><span class="n">refined_ids_end</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                           <span class="n">refined_ids_start</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span><span class="n">refined_ids_end</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
   <span class="k">return</span> <span class="n">arr</span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_test_variable_length</span><span class="p">(</span><span class="n">test_variable</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&#39;&#39;&#39; Check the size and dimensions of a test variable.</span>
<span class="sd">   Returns number of elements and shape of an np.ndarray, </span>
<span class="sd">   &#39;&#39;&#39;</span>
   <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_variable</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedConstant</span><span class="p">):</span>
      <span class="n">value_length</span><span class="o">=</span><span class="mi">1</span>
      <span class="n">value_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
   <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_variable</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
      <span class="n">value_length</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">test_variable</span><span class="p">)</span>
      <span class="n">value_shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">test_variable</span><span class="p">)</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="n">value_length</span><span class="o">=</span><span class="mi">1</span>
      <span class="n">value_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
   <span class="n">value_ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value_shape</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">value_length</span><span class="p">,</span> <span class="n">value_shape</span><span class="p">,</span> <span class="n">value_ndims</span>

<div class="viewcode-block" id="VlsvReader">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VlsvReader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&#39;&#39;&#39; Class for reading VLSV files</span>
<span class="sd">   &#39;&#39;&#39;</span> 


<span class="w">   </span><span class="sd">&#39;&#39;&#39; Meshinfo is an information container for multiple meshes.</span>
<span class="sd">       Implemented as an empty class.</span>
<span class="sd">   &#39;&#39;&#39;</span>
   <span class="k">class</span><span class="w"> </span><span class="nc">MeshInfo</span><span class="p">:</span>
      <span class="k">pass</span>

   <span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
   <span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;__fptr&quot;</span><span class="p">))</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

   <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">fsGridDecomposition</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Initializes the vlsv file (opens the file, reads the file footer and reads in some parameters)</span>

<span class="sd">          :param file_name:     Name of the vlsv file</span>
<span class="sd">          :param fsGridDecomposition: Either None or a len-3 list of ints.</span>
<span class="sd">                                       List (length 3): Use this as the decomposition directly. Product needs to match numWritingRanks.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="c1"># Make sure the path is set in file name: </span>
      <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span> <span class="o">=</span> <span class="n">file_name</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span> <span class="o">=</span> <span class="n">PicklableFile</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span><span class="s2">&quot;rb&quot;</span><span class="p">))</span>
      <span class="k">except</span> <span class="ne">FileNotFoundError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
         <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;File not found: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">)</span>
         <span class="k">raise</span> <span class="n">e</span>
      
      <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s2">&quot;&lt;VLSV&gt;&lt;/VLSV&gt;&quot;</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span><span class="o">=</span><span class="p">{}</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">__max_spatial_amr_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span> <span class="o">=</span> <span class="n">fsGridDecomposition</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">use_dict_for_blocks</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span><span class="o">=</span><span class="p">{}</span> <span class="c1"># [0] is index, [1] is blockcount</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__cells_with_blocks</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># per-pop</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># per-pop</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell_offsets</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># per-pop</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__order_for_cellid_blocks</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># per-pop</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span> <span class="c1"># SEE: map_vg_onto_fg(self)</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">variable_cache</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># {(varname, operator):data}</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">__pops_init</span> <span class="o">=</span> <span class="kc">False</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">__available_reducers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Set of strings of datareducer names</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__unavailable_reducers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Set of strings of datareducer names</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__current_reducer_tree_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Set of strings of datareducer names</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">__read_xml_footer</span><span class="p">()</span>
                              <span class="c1"># vertex-indices is a 3-tuple of integers</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__dual_cells</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)}</span> <span class="c1"># vertex-indices : 8-tuple of cellids at each corner (for x for y for z)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__dual_bboxes</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># vertex-indices : 6-list of (xmin, ymin, zmin, xmax, ymax, zmax) for the bounding box of each dual cell</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__cell_vertices</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># cellid : varying-length tuple of vertex-indices - includes hanging nodes!</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__cell_corner_vertices</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># cellid : varying-length tuple of vertex-indices - no hanging nodes!</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__cell_neighbours</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># cellid : set of cellids (all neighbors sharing a vertex)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__cell_duals</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># cellid : tuple of vertex-indices that span this cell</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__regular_neighbor_cache</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># cellid-of-low-corner : (8,) np.array of cellids)</span>

      <span class="c1"># Check if the file is using new or old vlsv format</span>
      <span class="c1"># Read parameters (Note: Reading the spatial cell locations and</span>
      <span class="c1"># storing them will anyway take the most time and memory):</span>

      <span class="n">meshName</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span>
      <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_BBOX&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">meshName</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
          <span class="k">try</span><span class="p">:</span>
              <span class="c1">#read in older vlsv files where the mesh is defined with parameters</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;xcells_ini&quot;</span><span class="p">))</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;ycells_ini&quot;</span><span class="p">))</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__zcells</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;zcells_ini&quot;</span><span class="p">))</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__xblock_size</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__yblock_size</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__zblock_size</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__xmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;xmin&quot;</span><span class="p">)</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;ymin&quot;</span><span class="p">)</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__zmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;zmin&quot;</span><span class="p">)</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;xmax&quot;</span><span class="p">)</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;ymax&quot;</span><span class="p">)</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__zmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;zmax&quot;</span><span class="p">)</span>
          <span class="k">except</span><span class="p">:</span>
              <span class="c1"># Apparently, SpatialGrid doesn&#39;t even exist in this file (because it is, for example an ionosphere test output)</span>
              <span class="c1"># Fill in dummy values.</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__zcells</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__xblock_size</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__yblock_size</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__zblock_size</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__xmin</span> <span class="o">=</span> <span class="mi">0</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__ymin</span> <span class="o">=</span> <span class="mi">0</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__zmin</span> <span class="o">=</span> <span class="mi">0</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__xmax</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__ymax</span> <span class="o">=</span> <span class="mi">1</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">__zmax</span> <span class="o">=</span> <span class="mi">1</span>


      <span class="k">else</span><span class="p">:</span>
         <span class="c1">#new style vlsv file with </span>
         <span class="n">nodeCoordinatesX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_NODE_CRDS_X&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">meshName</span><span class="p">)</span>   
         <span class="n">nodeCoordinatesY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_NODE_CRDS_Y&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">meshName</span><span class="p">)</span>   
         <span class="n">nodeCoordinatesZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_NODE_CRDS_Z&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">meshName</span><span class="p">)</span>   
         <span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__zcells</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__xblock_size</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__yblock_size</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__zblock_size</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__xmin</span> <span class="o">=</span> <span class="n">nodeCoordinatesX</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__ymin</span> <span class="o">=</span> <span class="n">nodeCoordinatesY</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__zmin</span> <span class="o">=</span> <span class="n">nodeCoordinatesZ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__xmax</span> <span class="o">=</span> <span class="n">nodeCoordinatesX</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__ymax</span> <span class="o">=</span> <span class="n">nodeCoordinatesY</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__zmax</span> <span class="o">=</span> <span class="n">nodeCoordinatesZ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">__dx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__xmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__dy</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ymax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ymin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__dz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__zmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__zmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">__zcells</span><span class="p">)</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">__meshes</span> <span class="o">=</span> <span class="p">{}</span>


      <span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="o">=</span><span class="p">[]</span> <span class="c1"># This lists all populations in the reader and is initialized at __init__</span>

      <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">cellsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dx</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_parameter</span><span class="p">(</span><span class="s2">&quot;j_per_b_modifier&quot;</span><span class="p">):</span>
         <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">J_per_B_modifier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;j_per_b_modifier&quot;</span><span class="p">)</span>

      <span class="c1"># This does not incur extra reads from disk -&gt; list and store all populations by iterating </span>
      <span class="c1"># through the XML tree and IDing populations by BLOCKIDS</span>
      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;BLOCKIDS&quot;</span><span class="p">:</span>
              <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                  <span class="n">popname</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> 
              <span class="k">else</span><span class="p">:</span>
                  <span class="n">popname</span> <span class="o">=</span> <span class="s2">&quot;avgs&quot;</span>
              
              <span class="c1"># Update list of active populations</span>
              <span class="k">if</span> <span class="ow">not</span> <span class="n">popname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">popname</span><span class="p">)</span>


      <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">__popmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">popname</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Get the population-specific vspace mesh info object, and initialize it if it does not exist</span>

<span class="sd">      :param popname: String, name of population to fetch info of</span>
<span class="sd">      :returns MeshInfo object containing velocity mesh info for the population</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">if</span> <span class="n">popname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meshes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meshes</span><span class="p">[</span><span class="n">popname</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__init_population</span><span class="p">(</span><span class="n">popname</span><span class="p">)</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">__init_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">popname</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Initialize metadata for a population. Incurs several small reads to the vlsv file,</span>
<span class="sd">          and initializes also the vlsvvariables.speciesprecipitationenergybins dict entry for this pop.</span>

<span class="sd">      :param popname: String, name of population to initialze</span>
<span class="sd">      :returns MeshInfo object containing velocity mesh info for the population</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="k">if</span> <span class="n">popname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meshes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meshes</span><span class="p">[</span><span class="n">popname</span><span class="p">]</span>

      <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_BBOX&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">popname</span><span class="p">)</span>
      <span class="n">pop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MeshInfo</span><span class="p">()</span>
      
      <span class="k">if</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;vxblocks_ini&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#read in older vlsv files where the mesh is defined with</span>
            <span class="c1">#parameters (only one possible)</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vxblocks</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;vxblocks_ini&quot;</span><span class="p">))</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vyblocks</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;vyblocks_ini&quot;</span><span class="p">))</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vzblocks</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;vzblocks_ini&quot;</span><span class="p">))</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vxblock_size</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># Old files will always have WID=4, newer files read it from bbox</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vyblock_size</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vzblock_size</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vxmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;vxmin&quot;</span><span class="p">)</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;vymin&quot;</span><span class="p">)</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vzmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;vzmin&quot;</span><span class="p">)</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vxmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;vxmax&quot;</span><span class="p">)</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;vymax&quot;</span><span class="p">)</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vzmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;vzmax&quot;</span><span class="p">)</span>
            <span class="c1"># Velocity cell lengths</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__dvx</span> <span class="o">=</span> <span class="p">((</span><span class="n">pop</span><span class="o">.</span><span class="n">__vxmax</span> <span class="o">-</span> <span class="n">pop</span><span class="o">.</span><span class="n">__vxmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="n">pop</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="n">pop</span><span class="o">.</span><span class="n">__vxblock_size</span><span class="p">)</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__dvy</span> <span class="o">=</span> <span class="p">((</span><span class="n">pop</span><span class="o">.</span><span class="n">__vymax</span> <span class="o">-</span> <span class="n">pop</span><span class="o">.</span><span class="n">__vymin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="n">pop</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="n">pop</span><span class="o">.</span><span class="n">__vyblock_size</span><span class="p">)</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__dvz</span> <span class="o">=</span> <span class="p">((</span><span class="n">pop</span><span class="o">.</span><span class="n">__vzmax</span> <span class="o">-</span> <span class="n">pop</span><span class="o">.</span><span class="n">__vzmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="n">pop</span><span class="o">.</span><span class="n">__vzblocks</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="n">pop</span><span class="o">.</span><span class="n">__vzblock_size</span><span class="p">)</span>

         <span class="k">else</span><span class="p">:</span>
            <span class="c1">#no velocity space in this file, e.g., file not written by Vlasiator </span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vxblocks</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vyblocks</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vzblocks</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vxblock_size</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vyblock_size</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vzblock_size</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vxmin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vymin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vzmin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vxmax</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vymax</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__vzmax</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Velocity cell lengths</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__dvx</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__dvy</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">__dvz</span> <span class="o">=</span> <span class="mi">1</span>

      <span class="k">else</span><span class="p">:</span>
         <span class="c1">#new style vlsv file with bounding box</span>
         <span class="n">nodeCoordinatesX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_NODE_CRDS_X&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">popname</span><span class="p">)</span>   
         <span class="n">nodeCoordinatesY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_NODE_CRDS_Y&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">popname</span><span class="p">)</span>   
         <span class="n">nodeCoordinatesZ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_NODE_CRDS_Z&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">popname</span><span class="p">)</span>   
         <span class="n">pop</span><span class="o">.</span><span class="n">__vxblocks</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__vyblocks</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__vzblocks</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__vxblock_size</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__vyblock_size</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__vzblock_size</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__vxmin</span> <span class="o">=</span> <span class="n">nodeCoordinatesX</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__vymin</span> <span class="o">=</span> <span class="n">nodeCoordinatesY</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__vzmin</span> <span class="o">=</span> <span class="n">nodeCoordinatesZ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__vxmax</span> <span class="o">=</span> <span class="n">nodeCoordinatesX</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__vymax</span> <span class="o">=</span> <span class="n">nodeCoordinatesY</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__vzmax</span> <span class="o">=</span> <span class="n">nodeCoordinatesZ</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
         <span class="c1"># Velocity cell lengths</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__dvx</span> <span class="o">=</span> <span class="p">((</span><span class="n">pop</span><span class="o">.</span><span class="n">__vxmax</span> <span class="o">-</span> <span class="n">pop</span><span class="o">.</span><span class="n">__vxmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="n">pop</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="n">pop</span><span class="o">.</span><span class="n">__vxblock_size</span><span class="p">)</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__dvy</span> <span class="o">=</span> <span class="p">((</span><span class="n">pop</span><span class="o">.</span><span class="n">__vymax</span> <span class="o">-</span> <span class="n">pop</span><span class="o">.</span><span class="n">__vymin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="n">pop</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="n">pop</span><span class="o">.</span><span class="n">__vyblock_size</span><span class="p">)</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__dvz</span> <span class="o">=</span> <span class="p">((</span><span class="n">pop</span><span class="o">.</span><span class="n">__vzmax</span> <span class="o">-</span> <span class="n">pop</span><span class="o">.</span><span class="n">__vzmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="n">pop</span><span class="o">.</span><span class="n">__vzblocks</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">float</span><span class="p">)(</span><span class="n">pop</span><span class="o">.</span><span class="n">__vzblock_size</span><span class="p">)</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">__meshes</span><span class="p">[</span><span class="n">popname</span><span class="p">]</span><span class="o">=</span><span class="n">pop</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;PTNONINTERACTIVE&#39;</span><span class="p">):</span>
         <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found population &quot;</span> <span class="o">+</span> <span class="n">popname</span><span class="p">)</span>
      
      <span class="c1"># Precipitation energy bins</span>
      <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">energybins</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">binexists</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">while</span> <span class="n">binexists</span><span class="p">:</span>
         <span class="n">binexists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_parameter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_PrecipitationCentreEnergy</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">popname</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
         <span class="k">if</span> <span class="n">binexists</span><span class="p">:</span>
            <span class="n">binvalue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_PrecipitationCentreEnergy</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">popname</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
            <span class="n">energybins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">binvalue</span><span class="p">)</span>
         <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
         <span class="n">pop</span><span class="o">.</span><span class="n">__precipitation_centre_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">energybins</span><span class="p">)</span>
         <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">speciesprecipitationenergybins</span><span class="p">[</span><span class="n">popname</span><span class="p">]</span> <span class="o">=</span> <span class="n">energybins</span>

      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meshes</span><span class="p">[</span><span class="n">popname</span><span class="p">]</span>
      

   <span class="k">def</span><span class="w"> </span><span class="nf">__init_populations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Initialize all populations contained in the file.</span>

<span class="sd">      ..seealso:: :func:`__init_population`</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pops_init</span><span class="p">:</span>
         <span class="k">return</span>
      
      <span class="k">for</span> <span class="n">popname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="p">:</span>
         <span class="n">pop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__init_population</span><span class="p">(</span><span class="n">popname</span><span class="p">)</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">__pops_init</span> <span class="o">=</span> <span class="kc">True</span>



   <span class="k">def</span><span class="w"> </span><span class="nf">__read_xml_footer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Reads in the XML footer of the VLSV file and store all the content</span>
<span class="sd">      &#39;&#39;&#39;</span> 
      <span class="c1">#(endianness,) = struct.unpack(&quot;c&quot;, fptr.read(1))</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
         <span class="n">fptr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">fptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span>
      <span class="c1"># Eight first bytes indicate whether the system is big_endianness or something else</span>
      <span class="n">endianness_offset</span> <span class="o">=</span> <span class="mi">8</span>
      <span class="n">fptr</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">endianness_offset</span><span class="p">)</span>
      <span class="c1"># Read 8 bytes as unsigned long long (uint64_t in this case) after endianness, this tells the offset of the XML file.</span>
      <span class="n">uint64_byte_amount</span> <span class="o">=</span> <span class="mi">8</span>
      <span class="p">(</span><span class="n">offset</span><span class="p">,)</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="n">fptr</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">uint64_byte_amount</span><span class="p">))</span>
      <span class="c1"># Move to the xml offset</span>
      <span class="n">fptr</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
      <span class="c1"># Read the xml data</span>
      <span class="n">xml_data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
      <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">fptr</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4096</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">chunk</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
             <span class="k">break</span>
          <span class="n">xml_data</span> <span class="o">+=</span> <span class="n">chunk</span>
      <span class="c1"># Read the xml as string</span>
      <span class="p">(</span><span class="n">xml_string</span><span class="p">,)</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">s&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">xml_data</span><span class="p">),</span> <span class="n">xml_data</span><span class="p">)</span>
      <span class="c1"># Input the xml data into xml_root</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">xml_string</span><span class="p">)</span>
      <span class="n">fptr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">__read_fileindex_for_cellid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&quot;&quot;&quot; Read in the cell ids and create an internal dictionary to give the index of an arbitrary cellID</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span> <span class="o">==</span> <span class="p">{}:</span>
         <span class="k">return</span>
      
      <span class="n">cellids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;CellID&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;VARIABLE&quot;</span><span class="p">)</span>

      <span class="c1">#Check if it is not iterable. If it is a scale then make it a list</span>
      <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cellids</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)):</span>
         <span class="n">cellids</span><span class="o">=</span><span class="p">[</span> <span class="n">cellids</span> <span class="p">]</span>
      <span class="c1"># self.__fileindex_for_cellid = {cellid:index for index,cellid in enumerate(cellids)}</span>
      <span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">cellid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cellids</span><span class="p">):</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span><span class="p">[</span><span class="n">cellid</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">__read_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellid</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read raw velocity block data from the open file.</span>
<span class="sd">      </span>
<span class="sd">      :param cellid: Cell ID of the cell whose velocity blocks are read</span>
<span class="sd">      :returns: A numpy array with block ids and their data</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_dict_for_blocks</span><span class="p">:</span> <span class="c1">#deprecated version</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__set_cell_offset_and_blocks</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>

         <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">cellid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">])</span> <span class="o">==</span> <span class="kc">False</span> <span class="p">):</span>
            <span class="c1"># Cell id has no blocks</span>
            <span class="k">return</span> <span class="p">[]</span>
         <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">cellid</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
         <span class="n">num_of_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">cellid</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="c1"># Uses arrays (much faster to initialize)</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cells_with_blocks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__set_cell_offset_and_blocks_nodict</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span> 
         <span class="c1"># Check that cells has vspace</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="n">cells_with_blocks_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__order_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">cellid</span><span class="p">]</span>
         <span class="k">except</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Cell does not have velocity distribution&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>
         <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell_offsets</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">cells_with_blocks_index</span><span class="p">]</span>
         <span class="n">num_of_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">cells_with_blocks_index</span><span class="p">]</span>


      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
         <span class="n">fptr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">fptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span>

      <span class="c1"># Read in avgs and velocity cell ids:</span>
      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
         <span class="c1"># Read in block values</span>
         <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">pop</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;BLOCKVARIABLE&quot;</span><span class="p">):</span>
            <span class="n">vector_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;vectorsize&quot;</span><span class="p">])</span>
            <span class="c1">#array_size = ast.literal_eval(child.attrib[&quot;arraysize&quot;])</span>
            <span class="n">element_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;datasize&quot;</span><span class="p">])</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;datatype&quot;</span><span class="p">]</span>

            <span class="c1"># Navigate to the correct position</span>
            <span class="n">offset_avgs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">vector_size</span> <span class="o">*</span> <span class="n">element_size</span> <span class="o">+</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
<span class="c1">#            for i in range(0, cells_with_blocks_index[0]):</span>
<span class="c1">#               offset_avgs += blocks_per_cell[i]*vector_size*element_size</span>

            <span class="n">fptr</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset_avgs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
               <span class="n">data_avgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">vector_size</span><span class="o">*</span><span class="n">num_of_blocks</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
               <span class="n">data_avgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">vector_size</span><span class="o">*</span><span class="n">num_of_blocks</span><span class="p">)</span>
            <span class="n">data_avgs</span> <span class="o">=</span> <span class="n">data_avgs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_of_blocks</span><span class="p">,</span> <span class="n">vector_size</span><span class="p">)</span>

         <span class="c1"># Read in block coordinates:</span>
         <span class="c1"># (note the special treatment in case the population is named &#39;avgs&#39;</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">pop</span> <span class="o">==</span> <span class="s1">&#39;avgs&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">pop</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;BLOCKIDS&quot;</span><span class="p">):</span>
            <span class="n">vector_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;vectorsize&quot;</span><span class="p">])</span>
            <span class="c1">#array_size = ast.literal_eval(child.attrib[&quot;arraysize&quot;])</span>
            <span class="n">element_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;datasize&quot;</span><span class="p">])</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;datatype&quot;</span><span class="p">]</span>

            <span class="n">offset_block_ids</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">vector_size</span> <span class="o">*</span> <span class="n">element_size</span> <span class="o">+</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>

            <span class="n">fptr</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset_block_ids</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;uint&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
               <span class="n">data_block_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">vector_size</span><span class="o">*</span><span class="n">num_of_blocks</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;uint&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
               <span class="n">data_block_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">vector_size</span><span class="o">*</span><span class="n">num_of_blocks</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error! Bad block id data!</span><span class="se">\n</span><span class="s2"> &quot;</span> \
                        <span class="s2">&quot;Data type: &quot;</span> <span class="o">+</span> <span class="n">datatype</span> <span class="o">+</span> <span class="s2">&quot;, element size: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">element_size</span><span class="p">))</span>
            <span class="n">data_block_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data_block_ids</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_block_ids</span><span class="p">),)</span> <span class="p">)</span>

      <span class="n">fptr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

      <span class="c1"># Check to make sure the sizes match (just some extra debugging)</span>
      <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;data_avgs = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">data_avgs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, data_block_ids = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">data_block_ids</span><span class="p">))</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_avgs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_block_ids</span><span class="p">):</span>
         <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;BAD DATA SIZES&quot;</span><span class="p">)</span>

      <span class="k">return</span> <span class="p">[</span><span class="n">data_block_ids</span><span class="p">,</span> <span class="n">data_avgs</span><span class="p">]</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">__set_cell_offset_and_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read blocks per cell and the offset in the velocity space arrays for</span>
<span class="sd">          every cell with blocks into a private dictionary.</span>
<span class="sd">          Deprecated in favor of below version.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Getting offsets for population &quot;</span> <span class="o">+</span> <span class="n">pop</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span><span class="p">:</span>
         <span class="c1"># There&#39;s stuff already saved into the dictionary, don&#39;t save it again</span>
         <span class="k">return</span>
      <span class="c1">#these two arrays are in the same order: </span>
      <span class="c1">#list of cells for which dist function is saved</span>
      <span class="n">cells_with_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;CELLSWITHBLOCKS&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">pop</span><span class="p">)</span>
      <span class="c1">#number of blocks in each cell for which data is stored</span>
      <span class="n">blocks_per_cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;BLOCKSPERCELL&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">pop</span><span class="p">)</span>

      <span class="k">try</span><span class="p">:</span>
         <span class="n">cells_with_blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;CELLSWITHBLOCKS&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">pop</span><span class="p">))</span>
         <span class="n">blocks_per_cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;BLOCKSPERCELL&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">pop</span><span class="p">))</span>
      <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="n">cells_with_blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;CELLSWITHBLOCKS&quot;</span><span class="p">))</span>
            <span class="n">blocks_per_cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;BLOCKSPERCELL&quot;</span><span class="p">))</span>
         <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e2</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Could not read CELLSWITHBLOCKS or BLOCKSPERCELL successfully, after first searching for &quot;</span> <span class="o">+</span><span class="n">pop</span><span class="o">+</span><span class="s2">&quot;/[CELLSWITHBLOCKS/BLOCKSPERCELL]/SpatialGrid and then without pop; errors raised: </span><span class="se">\n</span><span class="s2"> Firstly&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;,</span><span class="se">\n</span><span class="s2"> Secondly &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">e2</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">e2</span>

      <span class="c1"># Navigate to the correct position:</span>
      <span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">copy</span>
      <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="c1">#self.__fileindex_for_cellid_blocks[pop] = {}</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">cells_with_blocks</span><span class="p">)</span> <span class="c1"># should be faster but negligible difference</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells_with_blocks</span><span class="p">)):</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">cells_with_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="p">(</span><span class="n">offset</span><span class="p">),</span> <span class="n">copy</span><span class="p">(</span><span class="n">blocks_per_cell</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
         <span class="n">offset</span> <span class="o">+=</span> <span class="n">blocks_per_cell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">__set_cell_offset_and_blocks_nodict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read blocks per cell and the offset in the velocity space arrays for every cell with blocks.</span>
<span class="sd">          Stores them in arrays. Creates a private dictionary with addressing to the array.</span>
<span class="sd">          This method should be faster than the above function.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">if</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cells_with_blocks</span><span class="p">:</span>
         <span class="c1"># There&#39;s stuff already saved into the dictionary, don&#39;t save it again</span>
         <span class="k">return</span>

      <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Getting offsets for population &quot;</span> <span class="o">+</span> <span class="n">pop</span><span class="p">)</span>

      <span class="k">try</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__cells_with_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;CELLSWITHBLOCKS&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">pop</span><span class="p">))</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;BLOCKSPERCELL&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">pop</span><span class="p">))</span>
      <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cells_with_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;CELLSWITHBLOCKS&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;BLOCKSPERCELL&quot;</span><span class="p">))</span>
         <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e2</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Could not read CELLSWITHBLOCKS or BLOCKSPERCELL successfully, after first searching for &quot;</span> <span class="o">+</span><span class="n">pop</span><span class="o">+</span><span class="s2">&quot;/[CELLSWITHBLOCKS/BLOCKSPERCELL]/SpatialGrid and then without pop; errors raised: </span><span class="se">\n</span><span class="s2"> Firstly&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;,</span><span class="se">\n</span><span class="s2"> Secondly &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">e2</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">e2</span>


      <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell_offsets</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cells_with_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">]))</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell_offsets</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell_offsets</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell</span><span class="p">[</span><span class="n">pop</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__order_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">cellid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cells_with_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">]):</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__order_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">cellid</span><span class="p">]</span><span class="o">=</span><span class="n">index</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">__check_datareducer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">reducer</span><span class="p">):</span>

      <span class="n">reducer_ok</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__available_reducers</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
      <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unavailable_reducers</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
      <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__current_reducer_tree_nodes</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cyclical datareduction deteced with &quot;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;, this is weird and undefined!&quot;</span><span class="p">)</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">__current_reducer_tree_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

      <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">reducer</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;pop&quot;</span><span class="p">:</span>
            <span class="n">in_vars</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="p">:</span>
               <span class="n">popvar</span> <span class="o">=</span> <span class="n">pop</span><span class="o">+</span><span class="n">var</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
               <span class="k">if</span> <span class="n">popvar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__available_reducers</span><span class="p">:</span>
                  <span class="n">in_vars</span> <span class="o">=</span> <span class="kc">True</span>
               <span class="k">elif</span> <span class="n">popvar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unavailable_reducers</span><span class="p">:</span>
                  <span class="n">in_vars</span> <span class="o">=</span> <span class="kc">False</span>
               <span class="k">else</span><span class="p">:</span>
                  <span class="n">in_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_variable</span><span class="p">(</span><span class="n">popvar</span><span class="p">)</span>

               <span class="c1"># print(popvar,&quot; is in vars: &quot;,in_vars)</span>
               <span class="k">if</span> <span class="n">in_vars</span><span class="p">:</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">__available_reducers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">popvar</span><span class="p">)</span>
                  <span class="k">break</span>
               <span class="k">else</span><span class="p">:</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">__unavailable_reducers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">popvar</span><span class="p">)</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">in_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_variable</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

         <span class="c1"># reducer_ok = reducer_ok and in_vars</span>
         <span class="k">if</span> <span class="n">in_vars</span><span class="p">:</span>
            <span class="k">continue</span>

         <span class="n">in_reducers</span> <span class="o">=</span> <span class="p">((</span><span class="n">var</span> <span class="ow">in</span> <span class="n">datareducers</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="n">var</span> <span class="ow">in</span> <span class="n">multipopdatareducers</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="n">var</span> <span class="ow">in</span> <span class="n">v5reducers</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="n">var</span> <span class="ow">in</span> <span class="n">multipopv5reducers</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
         <span class="k">if</span> <span class="n">in_reducers</span><span class="p">:</span>
            <span class="n">reducer</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">reducer_reg</span> <span class="ow">in</span> <span class="p">[</span><span class="n">datareducers</span><span class="p">,</span> <span class="n">multipopdatareducers</span><span class="p">,</span> <span class="n">v5reducers</span><span class="p">,</span> <span class="n">multipopv5reducers</span><span class="p">]:</span>
               <span class="k">try</span><span class="p">:</span>
                  <span class="n">reducer</span> <span class="o">=</span> <span class="n">reducer_reg</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
               <span class="k">except</span><span class="p">:</span>
                  <span class="k">pass</span>

            <span class="n">reducer_ok</span> <span class="o">=</span> <span class="n">reducer_ok</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_datareducer</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">reducer</span><span class="p">)</span>
         <span class="k">else</span><span class="p">:</span> <span class="c1"># Not in variables not in datareducers, break</span>
            <span class="n">reducer_ok</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">break</span>

         <span class="k">if</span> <span class="ow">not</span> <span class="n">reducer_ok</span><span class="p">:</span> <span class="k">break</span>

      <span class="k">if</span> <span class="n">reducer_ok</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__available_reducers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unavailable_reducers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">reducer_ok</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">get_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

      <span class="n">varlist</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;VARIABLE&quot;</span> <span class="ow">and</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="n">varlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">varlist</span>
   
   <span class="k">def</span><span class="w"> </span><span class="nf">get_reducers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

      <span class="n">varlist</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="n">reducer_max_len</span> <span class="o">=</span> <span class="mi">0</span>
      
      <span class="k">for</span> <span class="n">reducer_reg</span> <span class="ow">in</span> <span class="p">[</span><span class="n">datareducers</span><span class="p">,</span> <span class="n">multipopdatareducers</span><span class="p">,</span> <span class="n">v5reducers</span><span class="p">,</span> <span class="n">multipopv5reducers</span><span class="p">]:</span>
         <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">reducer_reg</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">reducer_max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">reducer_max_len</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
      


      <span class="k">for</span> <span class="n">reducer_reg</span> <span class="ow">in</span> <span class="p">[</span><span class="n">datareducers</span><span class="p">,</span> <span class="n">multipopdatareducers</span><span class="p">,</span> <span class="n">v5reducers</span><span class="p">,</span> <span class="n">multipopv5reducers</span><span class="p">]:</span>
         <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">reducer</span> <span class="ow">in</span> <span class="n">reducer_reg</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__current_reducer_tree_nodes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_datareducer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">reducer</span><span class="p">):</span>
               <span class="k">if</span> <span class="n">name</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;pop&#39;</span><span class="p">:</span>
                  <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="p">:</span>
                     <span class="n">varlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pop</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">:])</span>
               <span class="k">else</span><span class="p">:</span>
                  <span class="n">varlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">varlist</span>


<div class="viewcode-block" id="VlsvReader.list">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.list">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">datareducer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Print out a description of the content of the file. Useful</span>
<span class="sd">         for interactive usage. Default is to list parameters and variables, query selection can be adjusted with keywords:</span>

<span class="sd">         Default and supported keywords:</span>

<span class="sd">         parameter=True </span>
<span class="sd">         variable=True</span>
<span class="sd">         mesh=False</span>
<span class="sd">         datareducer=False </span>
<span class="sd">         operator=False </span>
<span class="sd">         other=False</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">if</span> <span class="n">parameter</span><span class="p">:</span>
         <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tag = PARAMETER&quot;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;PARAMETER&quot;</span> <span class="ow">and</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
               <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   &quot;</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
      <span class="k">if</span> <span class="n">variable</span><span class="p">:</span>
         <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tag = VARIABLE&quot;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;VARIABLE&quot;</span> <span class="ow">and</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
               <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   &quot;</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
      <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span>
         <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tag = MESH&quot;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;MESH&quot;</span> <span class="ow">and</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
               <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   &quot;</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
      <span class="k">if</span> <span class="n">datareducer</span><span class="p">:</span>
         <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Datareducers (replace leading pop with a population name):&quot;</span><span class="p">)</span>

         <span class="n">reducer_max_len</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="n">units_max_len</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="k">for</span> <span class="n">reducer_reg</span> <span class="ow">in</span> <span class="p">[</span><span class="n">datareducers</span><span class="p">,</span> <span class="n">multipopdatareducers</span><span class="p">,</span> <span class="n">v5reducers</span><span class="p">,</span> <span class="n">multipopv5reducers</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">reducer_reg</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
               <span class="n">reducer_max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">reducer_max_len</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
               <span class="n">units_max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">units_max_len</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">reducer_reg</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">units</span><span class="p">))</span>


         <span class="k">for</span> <span class="n">reducer_reg</span> <span class="ow">in</span> <span class="p">[</span><span class="n">datareducers</span><span class="p">,</span> <span class="n">multipopdatareducers</span><span class="p">,</span> <span class="n">v5reducers</span><span class="p">,</span> <span class="n">multipopv5reducers</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">reducer</span> <span class="ow">in</span> <span class="n">reducer_reg</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">__current_reducer_tree_nodes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
               <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_datareducer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">reducer</span><span class="p">):</span>
                  <span class="nb">print</span><span class="p">(((</span><span class="s2">&quot;    %-&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">reducer_max_len</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">%</span> <span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">%-&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">units_max_len</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="o">+</span><span class="n">reducer</span><span class="o">.</span><span class="n">units</span><span class="o">+</span><span class="s2">&quot;]&quot;</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> based on &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">reducer_reg</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span><span class="p">))</span>

      <span class="k">if</span> <span class="n">operator</span><span class="p">:</span>
         <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data operators:&quot;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">data_operators</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
               <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                  <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   &quot;</span><span class="p">,</span><span class="n">name</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">other</span><span class="p">:</span>
         <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Other:&quot;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">!=</span> <span class="s2">&quot;PARAMETER&quot;</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">!=</span> <span class="s2">&quot;VARIABLE&quot;</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">!=</span> <span class="s2">&quot;MESH&quot;</span><span class="p">:</span>
               <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    tag = &quot;</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s2">&quot; mesh = &quot;</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="VlsvReader.check_parameter">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.check_parameter">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">check_parameter</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span> <span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Checks if a given parameter is in the vlsv reader</span>

<span class="sd">          :param name:             Name of the parameter</span>
<span class="sd">          :returns:                True if the parameter is in the vlsv file, false if not</span>

<span class="sd">          .. note:: This should be used for checking if a parameter exists, e.g. for different Vlasiator versions and time output</span>

<span class="sd">          .. code-block:: python</span>

<span class="sd">             # Example usage:</span>
<span class="sd">             vlsvReader = pt.vlsvfile.VlsvReader(&quot;test.vlsv&quot;)</span>
<span class="sd">             if vlsvReader.check_parameter( &quot;time&quot; ):</span>
<span class="sd">                time = vlsvReader.read_parameter(&quot;time&quot;)</span>
<span class="sd">             elif vlsvReader.check_parameter( &quot;t&quot; ):</span>
<span class="sd">                time = vlsvReader.read_parameter(&quot;t&quot;)</span>
<span class="sd">             else:</span>
<span class="sd">                time = None</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;PARAMETER&quot;</span> <span class="ow">and</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
               <span class="k">return</span> <span class="kc">True</span>
      <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="VlsvReader.check_variable">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.check_variable">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">check_variable</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span> <span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Checks if a given variable is in the vlsv reader</span>

<span class="sd">          :param name:             Name of the variable</span>
<span class="sd">          :returns:                True if the variable is in the vlsv file, false if not</span>

<span class="sd">          .. note:: This should be used for checking if a variable exists in case a function behaves differently for ex. if B vector is in the vlsv and if not</span>

<span class="sd">          .. code-block:: python</span>

<span class="sd">             # Example usage:</span>
<span class="sd">             vlsvReader = pt.vlsvfile.VlsvReader(&quot;test.vlsv&quot;)</span>
<span class="sd">             if vlsvReader.check_variable( &quot;B&quot; ):</span>
<span class="sd">                # Variable can be plotted</span>
<span class="sd">                plot_B()</span>
<span class="sd">             else:</span>
<span class="sd">                # Variable not in the vlsv file</span>
<span class="sd">                plot_B_vol()</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;VARIABLE&quot;</span> <span class="ow">and</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
               <span class="k">return</span> <span class="kc">True</span>
      <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="VlsvReader.check_population">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.check_population">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">check_population</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">popname</span> <span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Checks if a given population is in the vlsv file</span>

<span class="sd">          :param name:             Name of the population</span>
<span class="sd">          :returns:                True if the population is in the vlsv file, false if not</span>

<span class="sd">          .. code-block:: python</span>

<span class="sd">             # Example usage:</span>
<span class="sd">             vlsvReader = pt.vlsvfile.VlsvReader(&quot;test.vlsv&quot;)</span>
<span class="sd">             if vlsvReader.check_population( &quot;avgs&quot; ):</span>
<span class="sd">                plot_population(&#39;avgs&#39;)</span>
<span class="sd">             else:</span>
<span class="sd">                if vlsvReader.check_population( &quot;proton&quot; ):</span>
<span class="sd">                   # File is newer with proton population</span>
<span class="sd">                   plot_population(&#39;proton&#39;)</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">blockidsexist</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="n">foundpop</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;BLOCKIDS&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
               <span class="k">if</span> <span class="n">popname</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                  <span class="n">foundpop</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="n">blockidsexist</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">if</span> <span class="n">blockidsexist</span><span class="p">:</span>
         <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;BLOCKVARIABLE&quot;</span><span class="p">:</span>
               <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
                  <span class="k">if</span> <span class="n">popname</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> <span class="c1"># avgs</span>
                     <span class="n">foundpop</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">return</span> <span class="n">foundpop</span></div>


<div class="viewcode-block" id="VlsvReader.get_all_variables">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_all_variables">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_all_variables</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns all variables in the vlsv reader and the data reducer</span>
<span class="sd">          :returns:                List of variable is in the vlsv file</span>
<span class="sd">          .. code-block:: python</span>

<span class="sd">             # Example usage:</span>
<span class="sd">             vlsvReader = pt.vlsvfile.VlsvReader(&quot;test.vlsv&quot;)</span>
<span class="sd">             vars = vlsvReader.get_variables()</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">varlist</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;VARIABLE&quot;</span> <span class="ow">and</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="n">varlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
      <span class="k">return</span> <span class="n">varlist</span></div>


<div class="viewcode-block" id="VlsvReader.get_cellid_locations">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_cellid_locations">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_cellid_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns a dictionary with cell id as the key and the index of the cell id as the value. The index is used to locate the cell id&#39;s values in the arrays that this reader returns</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="c1"># if len( self.__fileindex_for_cellid ) == 0:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__read_fileindex_for_cellid</span><span class="p">()</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span></div>


<div class="viewcode-block" id="VlsvReader.print_version">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.print_version">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">print_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">      Prints version information from VLSV file.</span>
<span class="sd">      TAG is hardcoded to VERSION</span>

<span class="sd">      :returns True if version is found otherwise returns False</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
      <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;VERSION&quot;</span>
      <span class="c1"># Seek for requested data in VLSV file</span>
      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">tag</span><span class="p">:</span>
            <span class="k">continue</span>
         <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">:</span>
            <span class="c1"># Found the requested data entry in the file</span>
            <span class="n">array_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;arraysize&quot;</span><span class="p">])</span>
            <span class="n">variable_offset</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
               <span class="n">fptr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="n">fptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span>
         
            <span class="n">fptr</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">variable_offset</span><span class="p">)</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">fptr</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">array_size</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Version Info for &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

      <span class="c1">#if we end up here the file does not contain any version info</span>
      <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;File &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span><span class="s2">&quot; contains no version information&quot;</span><span class="p">)</span>
      <span class="k">return</span> <span class="kc">False</span></div>

  
<div class="viewcode-block" id="VlsvReader.get_config_string">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_config_string">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_config_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">      Gets config information from VLSV file.</span>
<span class="sd">      TAG is hardcoded to CONFIG</span>

<span class="sd">      :returns configuration file string if config is found otherwise returns None</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;CONFIG&quot;</span>
      <span class="c1"># Seek for requested data in VLSV file</span>
      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">tag</span><span class="p">:</span>
            <span class="k">continue</span>
         <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">:</span>
            <span class="c1"># Found the requested data entry in the file</span>
            <span class="n">array_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;arraysize&quot;</span><span class="p">])</span>
            <span class="n">variable_offset</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
               <span class="n">fptr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="n">fptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span>

            <span class="n">fptr</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">variable_offset</span><span class="p">)</span>
            <span class="n">configuration</span> <span class="o">=</span> <span class="n">fptr</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">array_size</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">configuration</span>

      <span class="c1">#if we end up here the file does not contain any config info</span>
      <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="VlsvReader.get_config">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_config">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">      Gets config information from VLSV file</span>

<span class="sd">      :returns a nested dictionary of dictionaries,</span>
<span class="sd">        where keys (str) are config file group headings (appearing in &#39;[]&#39;)</span>
<span class="sd">        and values are dictionaries which contain (lists of) strings </span>

<span class="sd">      If the same heading/parameter pair appears &gt;once in the config file,</span>
<span class="sd">      the different values are appended to the list .</span>

<span class="sd">      EXAMPLE:</span>
<span class="sd">      if the config contains these lines:</span>
<span class="sd">      </span>
<span class="sd">         [proton_precipitation]</span>
<span class="sd">         nChannels = 9</span>

<span class="sd">      then the following returns [&#39;9&#39;]:</span>
<span class="sd">      vlsvReader.get_config()[&#39;proton_precipitation&#39;][&#39;nChannels&#39;]</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">confstring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config_string</span><span class="p">()</span>
      <span class="k">if</span> <span class="n">confstring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="k">return</span> <span class="kc">None</span>
      <span class="n">fa</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\[\w+\]|\w+ = \S+&#39;</span><span class="p">,</span> <span class="n">confstring</span><span class="p">)</span>
      <span class="n">heading</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
      <span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="n">heading</span><span class="p">:{}}</span>

      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sfa</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fa</span><span class="p">):</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">sfa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;[&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sfa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;]&#39;</span><span class="p">):</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="n">sfa</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">output</span><span class="p">[</span><span class="n">heading</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">var_name</span> <span class="o">=</span> <span class="n">sfa</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">var_value</span> <span class="o">=</span> <span class="n">sfa</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">output</span><span class="p">[</span><span class="n">heading</span><span class="p">]:</span>
               <span class="c1"># when the same parameter is assigned a value multiple times</span>
               <span class="n">output</span><span class="p">[</span><span class="n">heading</span><span class="p">][</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="n">output</span><span class="p">[</span><span class="n">heading</span><span class="p">][</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">var_value</span><span class="p">]</span>

      <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="VlsvReader.print_config">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.print_config">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">print_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">      Prints config information from VLSV file.</span>

<span class="sd">      :returns True if config is found otherwise returns False</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">config_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config_string</span><span class="p">()</span>
      <span class="k">if</span> <span class="n">config_string</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
         <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">config_string</span><span class="p">)</span>
         <span class="k">return</span> <span class="kc">True</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="c1">#if we end up here the file does not contain any config info</span>
         <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;File &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span><span class="s2">&quot; contains no config information&quot;</span><span class="p">)</span>
         <span class="k">return</span> <span class="kc">False</span></div>


   <span class="k">def</span><span class="w"> </span><span class="nf">read_variable_vectorsize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>

      <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;fg_&#39;</span><span class="p">):</span>
          <span class="n">mesh</span> <span class="o">=</span> <span class="s2">&quot;fsgrid&quot;</span>
      <span class="k">elif</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ig_&#39;</span><span class="p">):</span>
          <span class="n">mesh</span> <span class="o">=</span> <span class="s2">&quot;ionosphere&quot;</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="n">mesh</span> <span class="o">=</span> <span class="s2">&quot;SpatialGrid&quot;</span>

      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_attribute</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span><span class="n">attribute</span><span class="o">=</span><span class="s2">&quot;vectorsize&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;VARIABLE&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="VlsvReader.read_attribute">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_attribute">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read data from the open vlsv file. </span>
<span class="sd">      </span>
<span class="sd">      :param name: Name of the data array</span>
<span class="sd">      :param tag:  Tag of the data array.</span>
<span class="sd">      :param mesh: Mesh for the data array</span>
<span class="sd">      :param operator: Datareduction operator. &quot;pass&quot; does no operation on data.</span>
<span class="sd">      :param cellids:  If -1 then all data is read. If nonzero then only the vector</span>
<span class="sd">                       for the specified cell id or cellids is read</span>
<span class="sd">      :returns: numpy array with the data</span>

<span class="sd">      .. seealso:: :func:`read_variable` :func:`read_variable_info`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
         <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Bad (empty) arguments at VlsvReader.read&quot;</span><span class="p">)</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

      <span class="c1"># Force lowercase name for internal checks</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>       

      <span class="c1"># Seek for requested data in VLSV file</span>
      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">tag</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">tag</span><span class="p">:</span>
               <span class="k">continue</span>
         <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
               <span class="k">continue</span>
         <span class="k">if</span> <span class="n">mesh</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;mesh&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mesh</span><span class="p">:</span>
               <span class="k">continue</span>
         <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">:</span>
            <span class="c1"># Found the requested data entry in the file</span>
            <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="n">attribute</span><span class="p">])</span>
         
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Variable or attribute not found&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="VlsvReader.read">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read data from the open vlsv file. </span>
<span class="sd">      </span>
<span class="sd">      :param name: Name of the data array</span>
<span class="sd">      :param tag:  Tag of the data array.</span>
<span class="sd">      :param mesh: Mesh for the data array</span>
<span class="sd">      :param operator: Datareduction operator. &quot;pass&quot; does no operation on data.</span>
<span class="sd">      :param cellids:  If -1 then all data is read. If nonzero then only the vector</span>
<span class="sd">                       for the specified cell id or cellids is read</span>
<span class="sd">      :returns: numpy array with the data</span>

<span class="sd">      .. seealso:: :func:`read_variable` :func:`read_variable_info`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
         <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Bad (empty) arguments at VlsvReader.read&quot;</span><span class="p">)</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

      <span class="k">if</span> <span class="n">mesh</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
         <span class="n">mesh</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

      <span class="c1"># Force lowercase name for internal checks</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

      <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;VARIABLE&quot;</span><span class="p">:</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">operator</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_cache</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable_from_cache</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cellids</span><span class="p">,</span> <span class="n">operator</span><span class="p">)</span>

      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cellids</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
         <span class="k">if</span> <span class="n">cellids</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">read_filelayout</span> <span class="o">=</span> <span class="kc">True</span>
         <span class="k">else</span><span class="p">:</span> <span class="c1"># cellids = -1</span>
            <span class="n">read_filelayout</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">read_filelayout</span> <span class="o">=</span> <span class="kc">True</span>
         <span class="c1"># Here could be a conditional optimization for unique CellIDs,</span>
         <span class="c1"># but it actually makes a very large query slower.</span>

      <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">read_filelayout</span><span class="p">:</span>
         <span class="c1"># Do we need to construct the cellid index?</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__read_fileindex_for_cellid</span><span class="p">()</span>
        
      <span class="c1"># Get population and variable names from data array name </span>
      <span class="k">if</span> <span class="s1">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
         <span class="n">popname</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
         <span class="k">if</span> <span class="n">popname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__init_population</span><span class="p">(</span><span class="n">popname</span><span class="p">)</span>  <span class="c1"># verify that the population is initialized</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">popname</span> <span class="o">=</span> <span class="s1">&#39;pop&#39;</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="n">name</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">popname</span> <span class="o">=</span> <span class="s1">&#39;pop&#39;</span>
         <span class="n">varname</span> <span class="o">=</span> <span class="n">name</span>

      <span class="c1"># Seek for requested data in VLSV file</span>
      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">tag</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">tag</span><span class="p">:</span>
               <span class="k">continue</span>
         <span class="c1"># Verify that any requested name or mesh matches those of the data</span>
         <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
               <span class="k">continue</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
               <span class="k">continue</span>
         <span class="k">if</span> <span class="n">mesh</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;mesh&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
               <span class="k">continue</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mesh</span><span class="p">:</span>
               <span class="k">continue</span>
         <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">:</span>
            <span class="c1"># Found the requested data entry in the file</span>
            <span class="n">vector_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;vectorsize&quot;</span><span class="p">])</span>
            <span class="n">array_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;arraysize&quot;</span><span class="p">])</span>
            <span class="n">element_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;datasize&quot;</span><span class="p">])</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;datatype&quot;</span><span class="p">]</span>
            <span class="n">variable_offset</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

            <span class="c1"># Define efficient method to read data in</span>
            <span class="n">reorder_data</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">arraydata</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">try</span><span class="p">:</span> <span class="c1"># try-except to see how many cellids were given</span>
               <span class="n">lencellids</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span> 
               <span class="c1"># Read multiple specified cells</span>
               <span class="c1"># If we&#39;re reading a large amount of single cells, it&#39;ll be faster to just read all</span>
               <span class="c1"># data from the file system and sort through it. For the CSC disk system, this</span>
               <span class="c1"># becomes more efficient for over ca. 5000 cellids.</span>
               <span class="k">if</span> <span class="n">lencellids</span><span class="o">&gt;</span><span class="mi">5000</span><span class="p">:</span> 
                  <span class="n">reorder_data</span> <span class="o">=</span> <span class="kc">True</span>
                  <span class="n">result_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span>
                  <span class="n">read_size</span> <span class="o">=</span> <span class="n">array_size</span>
                  <span class="n">read_offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
               <span class="k">else</span><span class="p">:</span> <span class="c1"># Read multiple cell ids one-by-one</span>
                  <span class="n">result_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span>
                  <span class="n">read_size</span> <span class="o">=</span> <span class="mi">1</span>
                  <span class="n">read_offsets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span><span class="o">*</span><span class="n">element_size</span><span class="o">*</span><span class="n">vector_size</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">cellids</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span> <span class="c1"># single cell or all cells</span>
               <span class="k">if</span> <span class="n">cellids</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># -1, read all cells</span>
                  <span class="n">result_size</span> <span class="o">=</span> <span class="n">array_size</span>
                  <span class="n">read_size</span> <span class="o">=</span> <span class="n">array_size</span>
                  <span class="n">read_offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
               <span class="k">else</span><span class="p">:</span> <span class="c1"># single cell id</span>
                  <span class="n">result_size</span> <span class="o">=</span> <span class="mi">1</span>
                  <span class="n">read_size</span> <span class="o">=</span> <span class="mi">1</span>
                  <span class="n">read_offsets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span><span class="p">[</span><span class="n">cellids</span><span class="p">]</span><span class="o">*</span><span class="n">element_size</span><span class="o">*</span><span class="n">vector_size</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
               <span class="n">fptr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="n">fptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span>

            <span class="k">for</span> <span class="n">r_offset</span> <span class="ow">in</span> <span class="n">read_offsets</span><span class="p">:</span>
               <span class="n">use_offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">variable_offset</span> <span class="o">+</span> <span class="n">r_offset</span><span class="p">)</span>
               <span class="n">fptr</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">use_offset</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">vector_size</span><span class="o">*</span><span class="n">read_size</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">vector_size</span><span class="o">*</span><span class="n">read_size</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">vector_size</span><span class="o">*</span><span class="n">read_size</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">vector_size</span><span class="o">*</span><span class="n">read_size</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;uint&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">vector_size</span><span class="o">*</span><span class="n">read_size</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;uint&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">vector_size</span><span class="o">*</span><span class="n">read_size</span><span class="p">)</span>
               <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">read_offsets</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
                  <span class="n">arraydata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="n">fptr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">read_offsets</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">reorder_data</span><span class="p">:</span>
               <span class="c1"># Many single cell id&#39;s requested</span>
               <span class="c1"># Pick the elements corresponding to the requested cells</span>
               <span class="n">arraydata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">vector_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                  <span class="n">arraydata</span><span class="o">=</span><span class="n">arraydata</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vector_size</span><span class="p">)</span>
                  
               <span class="n">append_offsets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">cellids</span><span class="p">]</span>
               <span class="n">data</span> <span class="o">=</span> <span class="n">arraydata</span><span class="p">[</span><span class="n">append_offsets</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
               <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">read_offsets</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
               <span class="c1"># Not-so-many single cell id&#39;s requested</span>
               <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arraydata</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">vector_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
               <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result_size</span><span class="p">,</span> <span class="n">vector_size</span><span class="p">)</span>
            
            <span class="c1"># If variable vector size is 1, and requested magnitude, change it to &quot;absolute&quot;</span>
            <span class="k">if</span> <span class="n">vector_size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">operator</span><span class="o">==</span><span class="s2">&quot;magnitude&quot;</span><span class="p">:</span>
               <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Data variable with vector size 1: Changed magnitude operation to absolute&quot;</span><span class="p">)</span>
               <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;absolute&quot;</span>

            <span class="k">if</span> <span class="n">result_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">data_operators</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">data_operators</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="n">data</span><span class="p">)</span>
      
      <span class="c1"># Check which set of datareducers to use</span>
      <span class="k">if</span> <span class="s1">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">popname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="p">:</span>
         <span class="n">checkname</span> <span class="o">=</span> <span class="s1">&#39;pop/&#39;</span><span class="o">+</span><span class="n">varname</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">checkname</span> <span class="o">=</span> <span class="n">varname</span>

      <span class="k">if</span> <span class="n">checkname</span> <span class="ow">in</span> <span class="n">deprecated_datareducers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">deprecated_datareducers</span><span class="p">[</span><span class="n">checkname</span><span class="p">]</span> <span class="p">)</span>

      <span class="k">if</span> <span class="n">varname</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;vg_&quot;</span> <span class="ow">or</span> <span class="n">varname</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;ig_&quot;</span><span class="p">:</span>
         <span class="n">reducer_reg</span> <span class="o">=</span> <span class="n">v5reducers</span>
         <span class="n">reducer_multipop</span> <span class="o">=</span> <span class="n">multipopv5reducers</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">reducer_reg</span> <span class="o">=</span> <span class="n">datareducers</span>
         <span class="n">reducer_multipop</span> <span class="o">=</span> <span class="n">multipopdatareducers</span>

         
            
      <span class="c1"># If this is a variable that can be summed over the populations (Ex. rho, PTensorDiagonal, ...)</span>
      <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;active_populations&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_variable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">name</span><span class="p">):</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__init_populations</span><span class="p">()</span>  <span class="c1"># verify all populations have been initialized</span>
         <span class="n">tmp_vars</span> <span class="o">=</span> <span class="p">[]</span>
         <span class="k">for</span> <span class="n">pname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="p">:</span>
            <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">activepopulation</span> <span class="o">=</span> <span class="n">pname</span>
            <span class="n">tmp_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="n">pname</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">name</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">cellids</span> <span class="p">)</span> <span class="p">)</span>
         <span class="k">return</span> <span class="n">data_operators</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="n">data_operators</span><span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">](</span><span class="n">tmp_vars</span><span class="p">))</span>

      <span class="c1"># Check if the name is in datareducers</span>
      <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">reducer_reg</span><span class="p">:</span>
         <span class="n">reducer</span> <span class="o">=</span> <span class="n">reducer_reg</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
         <span class="c1"># Read the necessary variables:</span>

         <span class="c1"># If variable vector size is 1, and requested magnitude, change it to &quot;absolute&quot;</span>
         <span class="k">if</span> <span class="n">reducer</span><span class="o">.</span><span class="n">vector_size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">operator</span><span class="o">==</span><span class="s2">&quot;magnitude&quot;</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Data reducer with vector size 1: Changed magnitude operation to absolute&quot;</span><span class="p">)</span>
            <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;absolute&quot;</span>

         <span class="c1"># Return the output of the datareducer</span>
         <span class="k">if</span> <span class="n">reducer</span><span class="o">.</span><span class="n">useVspace</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reducer</span><span class="o">.</span><span class="n">useReader</span><span class="p">:</span>
            <span class="n">actualcellids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CellID&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;VARIABLE&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=</span><span class="n">cellids</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actualcellids</span><span class="p">))</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">singlecellid</span> <span class="ow">in</span> <span class="n">actualcellids</span><span class="p">:</span>
               <span class="n">velocity_cell_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_velocity_cells</span><span class="p">(</span><span class="n">singlecellid</span><span class="p">)</span>
               <span class="c1"># Get cells:</span>
               <span class="n">vcellids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">velocity_cell_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
               <span class="c1"># Get coordinates:</span>
               <span class="n">velocity_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_velocity_cell_coordinates</span><span class="p">(</span><span class="n">vcellids</span><span class="p">)</span>
               <span class="n">tmp_vars</span> <span class="o">=</span> <span class="p">[]</span>
               <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">reducer</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
                  <span class="n">tmp_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">singlecellid</span> <span class="p">)</span> <span class="p">)</span>
               <span class="n">output</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">.</span><span class="n">operation</span><span class="p">(</span> <span class="n">tmp_vars</span> <span class="p">,</span> <span class="n">velocity_cell_data</span><span class="p">,</span> <span class="n">velocity_coordinates</span> <span class="p">)</span>
               <span class="n">index</span><span class="o">+=</span><span class="mi">1</span>
               <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actualcellids</span><span class="p">)))</span>
            
            <span class="k">if</span> <span class="n">reducer</span><span class="o">.</span><span class="n">useReader</span><span class="p">:</span>
               <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Combined useVspace and useReader reducers not implemented!&quot;</span><span class="p">)</span>
               <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">data_operators</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="n">output</span><span class="p">)</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp_vars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">reducer</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
               <span class="n">tmp_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">cellids</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">reducer</span><span class="o">.</span><span class="n">useReader</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">data_operators</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="n">reducer</span><span class="o">.</span><span class="n">operation</span><span class="p">(</span> <span class="n">tmp_vars</span><span class="p">,</span> <span class="bp">self</span> <span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">data_operators</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="n">reducer</span><span class="o">.</span><span class="n">operation</span><span class="p">(</span> <span class="n">tmp_vars</span> <span class="p">))</span>

      <span class="c1"># Check if the name is in multipop datareducers</span>
      <span class="k">if</span> <span class="s1">&#39;pop/&#39;</span><span class="o">+</span><span class="n">varname</span> <span class="ow">in</span> <span class="n">reducer_multipop</span><span class="p">:</span>

         <span class="n">reducer</span> <span class="o">=</span> <span class="n">reducer_multipop</span><span class="p">[</span><span class="s1">&#39;pop/&#39;</span><span class="o">+</span><span class="n">varname</span><span class="p">]</span>
         <span class="c1"># If variable vector size is 1, and requested magnitude, change it to &quot;absolute&quot;</span>
         <span class="k">if</span> <span class="n">reducer</span><span class="o">.</span><span class="n">vector_size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">operator</span><span class="o">==</span><span class="s2">&quot;magnitude&quot;</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Data reducer with vector size 1: Changed magnitude operation to absolute&quot;</span><span class="p">)</span>
            <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;absolute&quot;</span>

         <span class="k">if</span> <span class="n">reducer</span><span class="o">.</span><span class="n">useVspace</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error: useVspace flag is not implemented for multipop datareducers!&quot;</span><span class="p">)</span> 
            <span class="k">return</span>

         <span class="c1"># sum over populations</span>
         <span class="k">if</span> <span class="n">popname</span><span class="o">==</span><span class="s1">&#39;pop&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__init_populations</span><span class="p">()</span>
            <span class="c1"># Read the necessary variables:</span>
            <span class="n">tmp_vars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="p">:</span>
               <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">activepopulation</span> <span class="o">=</span> <span class="n">pname</span>
               <span class="n">tmp_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="n">pname</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">varname</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">cellids</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">data_operators</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="n">data_operators</span><span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">](</span><span class="n">tmp_vars</span><span class="p">))</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">activepopulation</span> <span class="o">=</span> <span class="n">popname</span>

         <span class="c1"># Read the necessary variables:</span>
         <span class="n">tmp_vars</span> <span class="o">=</span> <span class="p">[]</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">reducer</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;/&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
               <span class="n">tmp_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">cellids</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="n">tvar</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
               <span class="n">tmp_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span> <span class="n">popname</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">tvar</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">cellids</span> <span class="p">)</span> <span class="p">)</span>
         <span class="k">if</span> <span class="n">reducer</span><span class="o">.</span><span class="n">useReader</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data_operators</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="n">reducer</span><span class="o">.</span><span class="n">operation</span><span class="p">(</span> <span class="n">tmp_vars</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data_operators</span><span class="p">[</span><span class="n">operator</span><span class="p">](</span><span class="n">reducer</span><span class="o">.</span><span class="n">operation</span><span class="p">(</span> <span class="n">tmp_vars</span> <span class="p">))</span>

      <span class="k">if</span> <span class="n">name</span><span class="o">!=</span><span class="s2">&quot;&quot;</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error: variable &quot;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">tag</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">mesh</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">operator</span><span class="o">+</span><span class="s2">&quot; not found in .vlsv file or in data reducers!&quot;</span><span class="p">)</span> </div>




<div class="viewcode-block" id="VlsvReader.read_metadata">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_metadata">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read variable metadata from the open vlsv file. </span>
<span class="sd">      </span>
<span class="sd">      :param name: Name of the data array</span>
<span class="sd">      :param tag:  Tag of the data array.</span>
<span class="sd">      :param mesh: Mesh for the data array</span>
<span class="sd">      :returns: four strings:</span>
<span class="sd">                the unit of the variable as a regular string</span>
<span class="sd">                the unit of the variable as a LaTeX-formatted string</span>
<span class="sd">                the description of the variable as a LaTeX-formatted string</span>
<span class="sd">                the conversion factor to SI units as a string                  </span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
         <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Bad arguments at read&quot;</span><span class="p">)</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
         <span class="n">fptr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">fptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span>

      <span class="c1"># Force lowercase name for internal checks</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
      
      <span class="c1"># Seek for requested data in VLSV file</span>
      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>         
         <span class="k">if</span> <span class="n">tag</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">tag</span><span class="p">:</span>
               <span class="k">continue</span>
         <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
               <span class="k">continue</span>
         <span class="k">if</span> <span class="n">mesh</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;mesh&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mesh</span><span class="p">:</span>
               <span class="k">continue</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="k">continue</span>
         <span class="c1"># Found the requested data entry in the file</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]</span>
         <span class="k">except</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="n">unitLaTeX</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;unitLaTeX&quot;</span><span class="p">]</span>
         <span class="k">except</span><span class="p">:</span>
            <span class="n">unitLaTeX</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="n">variableLaTeX</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;variableLaTeX&quot;</span><span class="p">]</span>
         <span class="k">except</span><span class="p">:</span>
            <span class="n">variableLaTeX</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="n">unitConversion</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;unitConversion&quot;</span><span class="p">]</span> 
         <span class="k">except</span><span class="p">:</span>
            <span class="n">unitConversion</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
         <span class="k">return</span> <span class="n">unit</span><span class="p">,</span> <span class="n">unitLaTeX</span><span class="p">,</span> <span class="n">variableLaTeX</span><span class="p">,</span> <span class="n">unitConversion</span>
            
      <span class="k">if</span> <span class="n">name</span><span class="o">!=</span><span class="s2">&quot;&quot;</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error: variable &quot;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">tag</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">mesh</span><span class="o">+</span><span class="s2">&quot; not found in .vlsv file!&quot;</span> <span class="p">)</span>
      <span class="n">fptr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>

   


<div class="viewcode-block" id="VlsvReader.read_interpolated_fsgrid_variable">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_interpolated_fsgrid_variable">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_interpolated_fsgrid_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">,</span><span class="n">periodic</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read a linearly interpolated FSgrid variable value from the open vlsv file. Feel free to vectorize!</span>
<span class="sd">      Note that this does not account for varying centerings of fsgrid data.</span>
<span class="sd">      Arguments:</span>
<span class="sd">      :param name: Name of the (FSgrid) variable</span>
<span class="sd">      :param coords: Coordinates from which to read data </span>
<span class="sd">      :param periodic: Periodicity of the system. Default is periodic in all dimension</span>
<span class="sd">      :param operator: Datareduction operator. &quot;pass&quot; does no operation on data</span>
<span class="sd">      :returns: numpy array with the data</span>

<span class="sd">      .. seealso:: :func:`read` :func:`read_variable_info`</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;Linear&quot;</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;interpolation method &quot;</span><span class="o">+</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot; not implemented for read_interpolated_fsgrid_variable, only linear supported so far.&quot;</span><span class="p">)</span>
      
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;read_interpolated_fsgrid_variable: face- vs. edge- centered variables not accounted for!&quot;</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;fg_&#39;</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Interpolation of FsGrid called on non-FsGrid data; exiting.&quot;</span><span class="p">)</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">periodic</span><span class="p">)</span><span class="o">!=</span><span class="mi">3</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Periodic must be a list of 3 booleans.&quot;</span><span class="p">)</span>

      <span class="c1">#First off let&#39;s fetch the data and some meta</span>
      <span class="n">fg_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_fsgrid_variable</span><span class="p">(</span> <span class="n">name</span><span class="p">,</span><span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
      <span class="n">fg_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_size</span><span class="p">()</span>
      <span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">,</span><span class="n">nz</span><span class="o">=</span><span class="n">fg_size</span>
      <span class="n">extents</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_extent</span><span class="p">()</span>
      <span class="n">xmin</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">zmin</span><span class="p">,</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymax</span><span class="p">,</span><span class="n">zmax</span><span class="o">=</span><span class="n">extents</span>
      <span class="n">dx</span><span class="o">=</span><span class="nb">abs</span><span class="p">((</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="n">nx</span><span class="p">)</span>
      <span class="n">dy</span><span class="o">=</span><span class="nb">abs</span><span class="p">((</span><span class="n">ymax</span><span class="o">-</span><span class="n">ymin</span><span class="p">)</span><span class="o">/</span><span class="n">ny</span><span class="p">)</span>
      <span class="n">dz</span><span class="o">=</span><span class="nb">abs</span><span class="p">((</span><span class="n">zmax</span><span class="o">-</span><span class="n">zmin</span><span class="p">)</span><span class="o">/</span><span class="n">nz</span><span class="p">)</span>

      <span class="k">def</span><span class="w"> </span><span class="nf">getFsGridIndices</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
<span class="w">         </span><span class="sd">&#39;&#39;&#39; </span>
<span class="sd">         Returns indices based on boundary conditions</span>
<span class="sd">         &#39;&#39;&#39;</span>
         <span class="n">ind</span><span class="o">=-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">))</span>
         <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="c1">#Non periodic case</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">index</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span><span class="o">&gt;</span><span class="n">fg_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">periodic</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
               <span class="c1"># Returns False, interpolateSingle converts that to nans</span>
               <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Requested fsgrid index for interpolation outside simulation domain.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
               <span class="k">return</span> <span class="kc">False</span>
             <span class="c1"># Here we are either periodic or (not periodic and inside the domain)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">fg_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">ind</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="o">%</span><span class="n">fg_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">index</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">index</span><span class="o">&lt;=</span><span class="n">fg_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">ind</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#If we end up here then something is really wrong</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;FsGrid interpolation ran into a failure and could not locate all neighbors.&quot;</span><span class="p">,</span><span class="s2">&quot;Indices in question= &quot;</span><span class="p">,</span><span class="n">indices</span><span class="p">)</span>

         <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> 



      <span class="k">def</span><span class="w"> </span><span class="nf">interpolateSingle</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
<span class="w">         </span><span class="sd">&#39;&#39;&#39; </span>
<span class="sd">         Simple trilinear routine for interpolating fsGrid quantities </span>
<span class="sd">         at arbitrary coordinates r.</span>
<span class="sd">         Inputs:</span>
<span class="sd">             r: array of coordinates at which to perform the interpolation. </span>
<span class="sd">                Example: r=[x,y,z] in meters</span>
<span class="sd">         Outputs:</span>
<span class="sd">             Numpy array with interpolated data at r. Can be scalar or vector.</span>
<span class="sd">         &#39;&#39;&#39;</span>
         <span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
         <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">!=</span><span class="mi">3</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Interpolation cannot be performed. Exiting&quot;</span><span class="p">)</span>

         <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">r</span>
         <span class="n">xl</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">))</span>
         <span class="n">yl</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">y</span><span class="o">-</span><span class="n">ymin</span><span class="p">)</span><span class="o">/</span><span class="n">dy</span><span class="p">))</span>
         <span class="n">zl</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">z</span><span class="o">-</span><span class="n">zmin</span><span class="p">)</span><span class="o">/</span><span class="n">dz</span><span class="p">))</span>
    
         <span class="c1">#Normalize distances in a unit cube </span>
         <span class="n">xd</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span> <span class="o">-</span> <span class="n">xl</span>
         <span class="n">yd</span><span class="o">=</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">ymin</span><span class="p">)</span><span class="o">/</span><span class="n">dy</span> <span class="o">-</span> <span class="n">yl</span>
         <span class="n">zd</span><span class="o">=</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">zmin</span><span class="p">)</span><span class="o">/</span><span class="n">dz</span> <span class="o">-</span> <span class="n">zl</span>
       
         <span class="c1"># Calculate Neighbors&#39; Weights</span>
         <span class="n">w</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
         <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">xd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">yd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">zd</span><span class="p">)</span>
         <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">yd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">zd</span><span class="p">)</span>
         <span class="n">w</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">xd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">yd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">zd</span><span class="p">)</span>
         <span class="n">w</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">yd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">zd</span><span class="p">)</span>
         <span class="n">w</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">xd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">yd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">zd</span><span class="p">)</span>
         <span class="n">w</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">yd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">zd</span><span class="p">)</span>
         <span class="n">w</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">xd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">yd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">zd</span><span class="p">)</span>
         <span class="n">w</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">yd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">zd</span><span class="p">)</span>

         <span class="n">retval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">fg_data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
               <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                  <span class="n">retind</span><span class="o">=</span><span class="n">getFsGridIndices</span><span class="p">([</span><span class="n">xl</span><span class="o">+</span><span class="n">i</span><span class="p">,</span><span class="n">yl</span><span class="o">+</span><span class="n">j</span><span class="p">,</span><span class="n">zl</span><span class="o">+</span><span class="n">k</span><span class="p">])</span>
                  <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">retind</span><span class="p">):</span> <span class="n">retval</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="c1"># outside of a non periodic domain</span>
                  <span class="n">retval</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">fg_data</span><span class="p">[</span><span class="n">retind</span><span class="p">]</span>

         <span class="k">return</span> <span class="n">retval</span>

      <span class="n">ret</span><span class="o">=</span><span class="p">[]</span>
      <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">:</span>
         <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolateSingle</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>


<div class="viewcode-block" id="VlsvReader.read_interpolated_ionosphere_variable">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_interpolated_ionosphere_variable">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_interpolated_ionosphere_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read a linearly interpolated ionosphere variable value from the open vlsv file.</span>
<span class="sd">      Arguments:</span>
<span class="sd">      :param name: Name of the (ionosphere) variable</span>
<span class="sd">      :param coords: Coordinates (x,y,z) from which to read data </span>
<span class="sd">      :param operator: Datareduction operator. &quot;pass&quot; does no operation on data</span>
<span class="sd">      :param method: Interpolation method. Not implemented; barycentric interp would fall under linear.</span>
<span class="sd">      :returns: numpy array with the data</span>

<span class="sd">      .. seealso:: :func:`read` :func:`read_variable_info`</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="c1"># At this stage, this function has not yet been implemented -- logging.info a warning and exit</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Interpolation of ionosphere variables has not yet been implemented; exiting.&#39;</span><span class="p">)</span></div>


   <span class="c1"># These are the 8 cells that span the upper corner vertex on a regular grid</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_vg_regular_interp_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellids</span><span class="p">,</span> <span class="n">periodic</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]):</span>

      
      <span class="n">len_cellids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">cellid_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">len_cellids</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

      <span class="n">in_cache</span> <span class="o">=</span> <span class="n">dict_keys_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__regular_neighbor_cache</span><span class="p">,</span> <span class="n">cellids</span><span class="p">)</span>
      
      <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">in_cache</span><span class="p">)):</span>
         <span class="n">cellid_neighbors</span><span class="p">[</span><span class="n">in_cache</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="n">cellids</span><span class="p">[</span><span class="n">in_cache</span><span class="p">])(</span><span class="bp">self</span><span class="o">.</span><span class="n">__regular_neighbor_cache</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
      <span class="n">n_not_in_cache</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">in_cache</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">n_not_in_cache</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
         <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
               <span class="k">for</span> <span class="n">z</span>  <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                  <span class="n">offsets</span><span class="p">[</span><span class="n">ii</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                  <span class="n">ii</span><span class="o">+=</span><span class="mi">1</span>

         <span class="n">cellids_rep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">cellids</span><span class="p">[</span><span class="o">~</span><span class="n">in_cache</span><span class="p">]),</span> <span class="mi">8</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">n_not_in_cache</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
         <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="p">(</span><span class="n">n_not_in_cache</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
         <span class="n">cellid_neighbors_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_neighbor</span><span class="p">(</span><span class="n">cellids_rep</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">prune_uniques</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
         <span class="n">cellid_neighbors_new</span> <span class="o">=</span> <span class="n">cellid_neighbors_new</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__regular_neighbor_cache</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span><span class="n">cellid_neighbors_new</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cellids</span><span class="p">[</span><span class="o">~</span><span class="n">in_cache</span><span class="p">])})</span>
         <span class="n">cellid_neighbors</span><span class="p">[</span><span class="o">~</span><span class="n">in_cache</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">cellid_neighbors_new</span>
      
      <span class="k">return</span> <span class="n">cellid_neighbors</span>

<div class="viewcode-block" id="VlsvReader.read_interpolated_variable">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_interpolated_variable">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_interpolated_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">,</span><span class="n">periodic</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read a linearly interpolated variable value from the open vlsv file.</span>
<span class="sd">      Arguments:</span>
<span class="sd">      :param name: Name of the variable</span>
<span class="sd">      :param coords: Coordinates from which to read data </span>
<span class="sd">      :param periodic: Periodicity of the system. Default is periodic in all dimension</span>
<span class="sd">      :param operator: Datareduction operator. &quot;pass&quot; does no operation on data</span>
<span class="sd">      :param method: Interpolation method, default &quot;linear&quot;, options: [&quot;nearest&quot;, &quot;linear&quot;]</span>
<span class="sd">                     </span>
<span class="sd">      :returns: numpy array with the data</span>

<span class="sd">      .. seealso:: :func:`read` :func:`read_variable_info`</span>
<span class="sd">      &#39;&#39;&#39;</span>



      <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">periodic</span><span class="p">)</span><span class="o">!=</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Periodic must be a list of 3 booleans.&quot;</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">interp_method_aliases</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
         <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Updated alias &quot;</span> <span class="o">+</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot; -&gt; &quot;</span><span class="o">+</span><span class="n">interp_method_aliases</span><span class="p">[</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()])</span>
         <span class="n">method</span> <span class="o">=</span> <span class="n">interp_method_aliases</span><span class="p">[</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>

      <span class="c1"># First test whether the requested variable is on the FSgrid or ionosphre, and redirect to the dedicated function if needed</span>
      <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;fg_&#39;</span><span class="p">:</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_interpolated_fsgrid_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ig_&#39;</span><span class="p">:</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_interpolated_ionosphere_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

      <span class="c1"># case vg</span>

      <span class="n">coordinates</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
      <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
      
      <span class="n">stack</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coordinates</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
         <span class="n">stack</span> <span class="o">=</span> <span class="kc">False</span>
         <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

      <span class="c1"># Check one value for the length</span>
      <span class="n">test_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">cellids</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
      <span class="n">value_length</span><span class="p">,</span> <span class="n">value_shape</span><span class="p">,</span> <span class="n">value_ndims</span> <span class="o">=</span> <span class="n">get_test_variable_length</span><span class="p">(</span><span class="n">test_variable</span><span class="p">)</span>

      <span class="n">ncoords</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">if</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Coordinates are required to be three-dimensional (coords.shape[1]==3 or convertible to such))&quot;</span><span class="p">)</span>
      <span class="n">closest_cell_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cellid</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
         <span class="n">final_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=</span><span class="n">closest_cell_ids</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_values</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">final_values</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()[()]</span> <span class="c1"># The only special case to return a scalar instead of an array</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">final_values</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
      <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">method</span> <span class="o">+</span> <span class="s1">&#39; is not a valid interpolation method&#39;</span><span class="p">)</span>

      <span class="n">batch_closest_cell_coordinates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell_coordinates</span><span class="p">(</span><span class="n">closest_cell_ids</span><span class="p">)</span>
      
      <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
      <span class="n">offsets</span><span class="p">[</span><span class="n">coordinates</span> <span class="o">&lt;=</span> <span class="n">batch_closest_cell_coordinates</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

      <span class="c1"># This we cannot cache, unfortunately. np.unique on (closest_cell_ids,offsets) helps a bit in some cases.</span>
      <span class="n">lower_cell_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_neighbor</span><span class="p">(</span><span class="n">closest_cell_ids</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">prune_uniques</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

      <span class="n">lower_cell_ids_unique</span><span class="p">,</span> <span class="n">unique_cell_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lower_cell_ids</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">ngbrvalues</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">lower_cell_ids_unique</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="o">*</span><span class="n">value_shape</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

      <span class="n">cellid_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lower_cell_ids_unique</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">8</span><span class="p">))</span>
      <span class="n">cellid_neighbors</span><span class="p">[</span><span class="n">lower_cell_ids_unique</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vg_regular_interp_neighbors</span><span class="p">(</span><span class="n">lower_cell_ids_unique</span><span class="p">[</span><span class="n">lower_cell_ids_unique</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">periodic</span><span class="p">)</span>
      <span class="n">cellid_neighbors</span> <span class="o">=</span> <span class="n">cellid_neighbors</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
   

      <span class="n">lower_cell_coordinatess</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell_coordinates</span><span class="p">(</span><span class="n">lower_cell_ids_unique</span><span class="p">)</span>

      <span class="n">upper_cell_ids</span> <span class="o">=</span> <span class="n">cellid_neighbors</span><span class="p">[</span><span class="mi">7</span><span class="p">::</span><span class="mi">8</span><span class="p">]</span>
      <span class="n">upper_cell_coordinatess</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell_coordinates</span><span class="p">(</span><span class="n">upper_cell_ids</span><span class="p">)</span>

      <span class="n">scaled_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
      <span class="n">nonperiodic</span> <span class="o">=</span> <span class="n">lower_cell_coordinatess</span> <span class="o">!=</span> <span class="n">upper_cell_coordinatess</span>
      <span class="n">nonperiodic_all</span> <span class="o">=</span> <span class="n">nonperiodic</span><span class="p">[</span><span class="n">unique_cell_indices</span><span class="p">]</span>
      <span class="n">scaled_coordinates</span><span class="p">[</span><span class="n">nonperiodic_all</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="n">nonperiodic_all</span><span class="p">]</span> <span class="o">-</span> <span class="n">lower_cell_coordinatess</span><span class="p">[</span><span class="n">unique_cell_indices</span><span class="p">][</span><span class="n">nonperiodic_all</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">upper_cell_coordinatess</span><span class="p">[</span><span class="n">unique_cell_indices</span><span class="p">][</span><span class="n">nonperiodic_all</span><span class="p">]</span> <span class="o">-</span> <span class="n">lower_cell_coordinatess</span><span class="p">[</span><span class="n">unique_cell_indices</span><span class="p">][</span><span class="n">nonperiodic_all</span><span class="p">])</span>

      <span class="c1"># neighbour tuples can also overlap, so choose only unique ones here as well for reading (should be moved to read_variable)</span>
      <span class="n">cellids_neighbors_unique</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cellid_neighbors</span><span class="p">[</span><span class="n">cellid_neighbors</span><span class="o">!=</span><span class="mi">0</span><span class="p">],</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

      <span class="c1"># Read the corner values for required cells and apply repeats to match the initial coordinates</span>
      <span class="k">if</span> <span class="n">value_length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
         <span class="n">read_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=</span><span class="n">cellids_neighbors_unique</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
         <span class="n">ngbrvalues</span><span class="p">[</span><span class="n">cellid_neighbors</span><span class="o">!=</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">read_vals</span><span class="p">[</span><span class="n">indices</span><span class="p">,:]</span>
         <span class="c1"># ngbrvalues[cellid_neighbors!=0,:] = self.read_variable(name, cellids=cellid_neighbors[cellid_neighbors!=0], operator=operator)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">read_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=</span><span class="n">cellids_neighbors_unique</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
         <span class="n">ngbrvalues</span><span class="p">[</span><span class="n">cellid_neighbors</span><span class="o">!=</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">read_vals</span><span class="p">[</span><span class="n">indices</span><span class="p">,:]</span>
         <span class="c1"># ngbrvalues[cellid_neighbors!=0,:] = self.read_variable(name, cellids=cellid_neighbors[cellid_neighbors!=0], operator=operator)[:,np.newaxis]</span>
      <span class="c1"># ngbrvalues = np.reshape(ngbrvalues, (ncoords,2,2,2,value_length))</span>
      <span class="n">nvals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lower_cell_ids_unique</span><span class="p">)</span>
      <span class="n">ngbrvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ngbrvalues</span><span class="p">,</span> <span class="p">(</span><span class="n">nvals</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">*</span><span class="n">value_shape</span><span class="p">))</span>

      <span class="n">ngbrvalues</span> <span class="o">=</span> <span class="n">ngbrvalues</span><span class="p">[</span><span class="n">unique_cell_indices</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
      <span class="n">newax</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value_shape</span><span class="p">)])</span>
      <span class="n">c2ds</span> <span class="o">=</span> <span class="p">(</span><span class="n">ngbrvalues</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:,:,</span><span class="o">...</span><span class="p">]</span><span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">scaled_coordinates</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="n">newax</span><span class="p">))</span> <span class="o">+</span>  <span class="n">ngbrvalues</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:,:,</span><span class="o">...</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">scaled_coordinates</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="n">newax</span><span class="p">))</span>
      <span class="n">newax</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value_shape</span><span class="p">)])</span>
      <span class="n">c1ds</span> <span class="o">=</span> <span class="p">(</span><span class="n">c2ds</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:,</span><span class="o">...</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">scaled_coordinates</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="n">newax</span><span class="p">))</span> <span class="o">+</span> <span class="n">c2ds</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:,</span><span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">scaled_coordinates</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="n">newax</span><span class="p">))</span>
      <span class="n">newax</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value_shape</span><span class="p">))</span>
      <span class="n">final_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c1ds</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">scaled_coordinates</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="n">newax</span><span class="p">))</span> <span class="o">+</span> <span class="n">c1ds</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">scaled_coordinates</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="n">newax</span><span class="p">))</span>

      <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cellid_neighbors</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
         <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Coordinate in interpolation out of domain, output contains nans&quot;</span><span class="p">,</span><span class="ne">UserWarning</span><span class="p">)</span>

      
      <span class="n">refs0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_amr_level</span><span class="p">(</span><span class="n">cellid_neighbors</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
      <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">refs0</span> <span class="o">!=</span> <span class="n">refs0</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span><span class="n">axis</span> <span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
         <span class="n">irregs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">refs0</span> <span class="o">!=</span> <span class="n">refs0</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span><span class="n">axis</span> <span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="n">unique_cell_indices</span><span class="p">]</span>
         <span class="n">final_values</span><span class="p">[</span><span class="n">irregs</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_interpolated_variable_irregular</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">irregs</span><span class="p">],</span> <span class="n">operator</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">*</span><span class="n">value_shape</span><span class="p">))</span>
         <span class="c1"># warnings.warn(&quot;Interpolation across refinement levels. Results are now better, but some discontinuitues might appear. If that bothers, try the read_interpolated_variable_irregular variant directly.&quot;,UserWarning)</span>

      <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">final_values</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">value_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_values</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()[()]</span> <span class="c1"># The only special case to return a scalar instead of an array</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_values</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="VlsvReader.get_duals">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_duals">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_duals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cids</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Get the union of dual cells that cover each of CellIDs in cids.</span>
<span class="sd">          Assumes all required duals are defined! TODO handling of missing duals, do not call separately.</span>

<span class="sd">      :returns: Dict of vertex-indices v (3-tuple) : 8-tuple of cellids (corners of dual cells indexed by v)</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="n">fo</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cell_duals</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cids</span><span class="p">}</span>
      <span class="n">vset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
      <span class="n">vset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">fo</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
      <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dual_cells</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vset</span><span class="p">}</span></div>



<div class="viewcode-block" id="VlsvReader.read_interpolated_variable_irregular">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_interpolated_variable_irregular">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_interpolated_variable_irregular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">,</span><span class="n">periodic</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
                                            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                                            <span class="n">methodargs</span><span class="o">=</span><span class="p">{</span>
                                             <span class="s2">&quot;rbf&quot;</span><span class="p">:{</span><span class="s2">&quot;neighbors&quot;</span><span class="p">:</span><span class="mi">64</span><span class="p">},</span>
                                             <span class="s2">&quot;delaunay&quot;</span><span class="p">:{</span><span class="s2">&quot;qhull_options&quot;</span><span class="p">:</span><span class="s2">&quot;QJ&quot;</span><span class="p">}</span>
                                             <span class="p">}):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read a linearly interpolated variable value from the open vlsv file.</span>
<span class="sd">      Arguments:</span>

<span class="sd">      :param name:         Name of the variable</span>

<span class="sd">      :param coords:       Coordinates from which to read data </span>

<span class="sd">      :param periodic:     Periodicity of the system. Default is periodic in all dimension</span>

<span class="sd">      :param operator:     Datareduction operator. &quot;pass&quot; does no operation on data</span>


<span class="sd">      :param method:       Method for interpolation, default &quot;linear&quot; (&quot;nearest&quot;, &quot;rbf, &quot;delaunay&quot;)</span>

<span class="sd">      :param methodargs:   Dict of dicts to pass kwargs to interpolators. Default values for &quot;rbf&quot;, &quot;delaunay&quot;;</span>

<span class="sd">                           see scipy.interpolate.RBFInterpolator for rbf and scipy.interpolate.LinearNDInterpolator for delaunay</span>
<span class="sd">      :returns: numpy array with the data</span>

<span class="sd">      .. seealso:: :func:`read` :func:`read_variable_info`</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="n">stack</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">if</span> <span class="n">coords</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
         <span class="n">stack</span> <span class="o">=</span> <span class="kc">False</span>
         <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>

      <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">periodic</span><span class="p">)</span><span class="o">!=</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Periodic must be a list of 3 booleans.&quot;</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">interp_method_aliases</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
         <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Updated alias &quot;</span> <span class="o">+</span><span class="n">method</span><span class="o">+</span><span class="s2">&quot; -&gt; &quot;</span><span class="o">+</span><span class="n">interp_method_aliases</span><span class="p">[</span><span class="n">method</span><span class="p">])</span>
         <span class="n">method</span> <span class="o">=</span> <span class="n">interp_method_aliases</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
      

      <span class="c1"># First test whether the requested variable is on the FSgrid or ionosphre, and redirect to the dedicated function if needed</span>
      <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;fg_&#39;</span><span class="p">:</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_interpolated_fsgrid_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ig_&#39;</span><span class="p">:</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_interpolated_ionosphere_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

      <span class="c1"># Default case: AMR grid</span>

      <span class="n">coordinates</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
      <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

      
      <span class="n">ncoords</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">if</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Coordinates are required to be three-dimensional (coords.shape[1]==3 or convertible to such))&quot;</span><span class="p">)</span>
      <span class="n">cellids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cellid</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
         <span class="c1"># Check one value for the length</span>
         <span class="n">test_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">cellids</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
         <span class="n">value_length</span><span class="p">,</span> <span class="n">value_shape</span> <span class="o">=</span> <span class="n">get_test_variable_length</span><span class="p">(</span><span class="n">test_variable</span><span class="p">)</span>

         <span class="n">final_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=</span><span class="n">cellids</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_values</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">final_values</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()[()]</span> <span class="c1"># The only special case to return a scalar instead of an array</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">final_values</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>      <span class="c1"># Other methods</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_amr_interpolators</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">method</span> <span class="o">+</span> <span class="s1">&#39; is not a valid interpolation method for AMR grids&#39;</span><span class="p">)</span>

      <span class="n">containing_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">build_duals</span><span class="p">(</span><span class="n">containing_cells</span><span class="p">)</span>
      <span class="n">duals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_duals</span><span class="p">(</span><span class="n">containing_cells</span><span class="p">)</span>

      <span class="n">cells_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
      <span class="n">cells_set</span> <span class="o">=</span> <span class="n">cells_set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">duals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

      <span class="n">cells_set</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">intp_wrapper</span> <span class="o">=</span> <span class="n">AMRInterpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cellids</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cells_set</span><span class="p">)))</span>
      <span class="n">intp</span> <span class="o">=</span> <span class="n">intp_wrapper</span><span class="o">.</span><span class="n">get_interpolator</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">operator</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">methodargs</span><span class="o">=</span><span class="n">methodargs</span><span class="p">)</span>
      
      <span class="n">final_values</span> <span class="o">=</span> <span class="n">intp</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=</span><span class="n">cellids</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

      <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">final_values</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="c1"># this will be an array as long as this is still a multi-cell codepath!</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">final_value</span> <span class="o">=</span> <span class="n">final_values</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_value</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_value</span></div>



<div class="viewcode-block" id="VlsvReader.read_fsgrid_variable_cellid">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_fsgrid_variable_cellid">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_fsgrid_variable_cellid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Reads fsgrid variables from the open vlsv file.</span>
<span class="sd">       Arguments:</span>
<span class="sd">       :param name:     Name of the variable</span>
<span class="sd">       :param cellids:  SpatialGrid cellids for which to fetch data. Default: return full fsgrid data</span>
<span class="sd">       :param operator: Datareduction operator. &quot;pass&quot; does no operation on data</span>
<span class="sd">       :returns: *ordered* list of numpy arrays with the data</span>

<span class="sd">       ... seealso:: :func:`read_fsgrid_variable`</span>
<span class="sd">       &#39;&#39;&#39;</span>
      <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_fsgrid_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">cellids</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">var</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample_fsgrid_subarray</span><span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">cellids</span><span class="p">]</span></div>


<div class="viewcode-block" id="VlsvReader.read_fsgrid_variable">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_fsgrid_variable">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_fsgrid_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">):</span>
<span class="w">       </span><span class="sd">&#39;&#39;&#39; Reads fsgrid variables from the open vlsv file.</span>
<span class="sd">       Arguments:</span>
<span class="sd">       :param name: Name of the variable</span>
<span class="sd">       :param operator: Datareduction operator. &quot;pass&quot; does no operation on data</span>
<span class="sd">       :returns: *ordered* numpy array with the data</span>

<span class="sd">       ... seealso:: :func:`read_variable`</span>
<span class="sd">       &#39;&#39;&#39;</span>

       <span class="c1"># Get fsgrid domain size (this can differ from vlasov grid size if refined)</span>
       <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_size</span><span class="p">()</span>
       <span class="n">bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span>

       <span class="c1"># Read the raw array data</span>
       <span class="n">rawData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;fsgrid&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;VARIABLE&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>

       <span class="c1"># Determine fsgrid domain decomposition</span>
       <span class="n">numWritingRanks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;numWritingRanks&quot;</span><span class="p">)</span>
       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rawData</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
         <span class="n">orderedData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">rawData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
       <span class="k">else</span><span class="p">:</span>
         <span class="n">orderedData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

       <span class="k">def</span><span class="w"> </span><span class="nf">calcLocalStart</span><span class="p">(</span><span class="n">globalCells</span><span class="p">,</span> <span class="n">ntasks</span><span class="p">,</span> <span class="n">my_n</span><span class="p">):</span>
           <span class="n">n_per_task</span> <span class="o">=</span> <span class="n">globalCells</span><span class="o">//</span><span class="n">ntasks</span>
           <span class="n">remainder</span> <span class="o">=</span> <span class="n">globalCells</span><span class="o">%</span><span class="n">ntasks</span>
           <span class="k">if</span> <span class="n">my_n</span> <span class="o">&lt;</span> <span class="n">remainder</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">my_n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_per_task</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
           <span class="k">else</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">my_n</span> <span class="o">*</span> <span class="n">n_per_task</span> <span class="o">+</span> <span class="n">remainder</span>
       <span class="k">def</span><span class="w"> </span><span class="nf">calcLocalSize</span><span class="p">(</span><span class="n">globalCells</span><span class="p">,</span> <span class="n">ntasks</span><span class="p">,</span> <span class="n">my_n</span><span class="p">):</span>
           <span class="n">n_per_task</span> <span class="o">=</span> <span class="n">globalCells</span><span class="o">//</span><span class="n">ntasks</span>
           <span class="n">remainder</span> <span class="o">=</span> <span class="n">globalCells</span><span class="o">%</span><span class="n">ntasks</span>
           <span class="k">if</span> <span class="n">my_n</span> <span class="o">&lt;</span> <span class="n">remainder</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">n_per_task</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
           <span class="k">else</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">n_per_task</span>

       <span class="n">currentOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_DECOMPOSITION&quot;</span><span class="p">,</span><span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;fsgrid&#39;</span><span class="p">)</span>
         <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found FsGrid decomposition from vlsv file: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">))</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Did not find FsGrid decomposition from vlsv file.&quot;</span><span class="p">)</span>
       
       <span class="c1"># If decomposition is None even after reading, we need to calculate it:</span>
       <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
          <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating fsGrid decomposition from the file&quot;</span><span class="p">)</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span> <span class="o">=</span> <span class="n">fsDecompositionFromGlobalIds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
          <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computed FsGrid decomposition to be: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">))</span>
       <span class="k">else</span><span class="p">:</span>
          <span class="c1"># Decomposition is a list (or fail assertions below) - use it instead</span>
          <span class="k">pass</span>
          
       <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Manual FSGRID decomposition should have three elements, but is &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">)</span>
       <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">)</span> <span class="o">==</span> <span class="n">numWritingRanks</span><span class="p">,</span> <span class="s2">&quot;Manual FSGRID decomposition should have a product of numWritingRanks (&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">numWritingRanks</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;), but is &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; for decomposition &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">)</span>
               
          

       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">numWritingRanks</span><span class="p">):</span>
           <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
           <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
           <span class="n">z</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
 	   
           <span class="n">thatTasksSize</span> <span class="o">=</span> <span class="p">[</span><span class="n">calcLocalSize</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">),</span> \
                            <span class="n">calcLocalSize</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">),</span> \
                            <span class="n">calcLocalSize</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">z</span><span class="p">)]</span>
           <span class="n">thatTasksStart</span> <span class="o">=</span> <span class="p">[</span><span class="n">calcLocalStart</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">),</span> \
                             <span class="n">calcLocalStart</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">),</span> \
                             <span class="n">calcLocalStart</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fsGridDecomposition</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">z</span><span class="p">)]</span>
           
           <span class="n">thatTasksEnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">thatTasksStart</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">thatTasksSize</span><span class="p">)</span>
           <span class="n">totalSize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">thatTasksSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">thatTasksSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">thatTasksSize</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
           <span class="c1"># Extract datacube of that task... </span>
           <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rawData</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
               <span class="n">thatTasksData</span> <span class="o">=</span> <span class="n">rawData</span><span class="p">[</span><span class="n">currentOffset</span><span class="p">:</span><span class="n">currentOffset</span><span class="o">+</span><span class="n">totalSize</span><span class="p">,:]</span>
               <span class="n">thatTasksData</span> <span class="o">=</span> <span class="n">thatTasksData</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">thatTasksSize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">thatTasksSize</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">thatTasksSize</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">rawData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

               <span class="c1"># ... and put it into place </span>
               <span class="n">orderedData</span><span class="p">[</span><span class="n">thatTasksStart</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">thatTasksEnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">thatTasksStart</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">thatTasksEnd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">thatTasksStart</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">thatTasksEnd</span><span class="p">[</span><span class="mi">2</span><span class="p">],:]</span> <span class="o">=</span> <span class="n">thatTasksData</span>
           <span class="k">else</span><span class="p">:</span>
               <span class="c1"># Special case for scalar data</span>
               <span class="n">thatTasksData</span> <span class="o">=</span> <span class="n">rawData</span><span class="p">[</span><span class="n">currentOffset</span><span class="p">:</span><span class="n">currentOffset</span><span class="o">+</span><span class="n">totalSize</span><span class="p">]</span>
               <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">thatTasksData</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
                  <span class="n">thatTasksData</span> <span class="o">=</span> <span class="n">thatTasksData</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">thatTasksSize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">thatTasksSize</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">thatTasksSize</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

                  <span class="c1"># ... and put it into place</span>
                  <span class="n">orderedData</span><span class="p">[</span><span class="n">thatTasksStart</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">thatTasksEnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">thatTasksStart</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">thatTasksEnd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">thatTasksStart</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">thatTasksEnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">thatTasksData</span>

           <span class="n">currentOffset</span> <span class="o">+=</span> <span class="n">totalSize</span>

       <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">orderedData</span><span class="p">)</span></div>


   <span class="k">def</span><span class="w"> </span><span class="nf">read_fg_variable_as_volumetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">centering</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">):</span>
      <span class="n">fgdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_fsgrid_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">operator</span><span class="p">)</span>

      <span class="n">fssize</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_size</span><span class="p">())</span>
      <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">fssize</span><span class="p">:</span>
         <span class="c1">#expand to have a singleton dimension for a reduced dim - lets roll happen with ease</span>
         <span class="n">singletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fssize</span><span class="p">)</span> <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
         <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">singletons</span><span class="p">:</span>
            <span class="n">fgdata</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">fgdata</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fg_array_to_volumetric</span><span class="p">(</span><span class="n">fgdata</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">centering</span><span class="o">=</span><span class="n">centering</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">fg_array_to_volumetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fgdata</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">centering</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">):</span>
      <span class="n">celldata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">fgdata</span><span class="p">)</span>
      <span class="n">known_centerings</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;fg_b&quot;</span><span class="p">:</span><span class="s2">&quot;face&quot;</span><span class="p">,</span> <span class="s2">&quot;fg_e&quot;</span><span class="p">:</span><span class="s2">&quot;edge&quot;</span><span class="p">}</span>
      <span class="k">if</span> <span class="n">centering</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="n">centering</span> <span class="o">=</span> <span class="n">known_centerings</span><span class="p">[</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
         <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;A variable (&quot;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;) with unknown centering! Aborting.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
         
      <span class="c1">#vector variable</span>
      <span class="k">if</span> <span class="n">fgdata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">centering</span><span class="o">==</span><span class="s2">&quot;face&quot;</span><span class="p">:</span>
            <span class="n">celldata</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="n">celldata</span><span class="p">[:,:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="n">celldata</span><span class="p">[:,:,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">2</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="c1"># Use Leo&#39;s reconstuction for fg_b instead</span>
         <span class="k">elif</span> <span class="n">centering</span><span class="o">==</span><span class="s2">&quot;edge&quot;</span><span class="p">:</span>
            <span class="n">celldata</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span><span class="o">/</span><span class="mf">4.0</span>
            <span class="n">celldata</span><span class="p">[:,:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span><span class="o">/</span><span class="mf">4.0</span>
            <span class="n">celldata</span><span class="p">[:,:,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">2</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">2</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">fgdata</span><span class="p">[:,:,:,</span><span class="mi">2</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span><span class="o">/</span><span class="mf">4.0</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Unknown centering (&#39;&quot;</span> <span class="o">+</span><span class="n">centering</span><span class="o">+</span> <span class="s2">&quot;&#39;)! Aborting.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;A scalar variable! I don&#39;t know what to do with this! Aborting.&quot;</span><span class="p">)</span>
         <span class="k">return</span> <span class="kc">False</span>
      <span class="k">return</span> <span class="n">celldata</span>

<div class="viewcode-block" id="VlsvReader.read_ionosphere_variable">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_ionosphere_variable">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_ionosphere_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">):</span>
<span class="w">       </span><span class="sd">&#39;&#39;&#39; Reads fsgrid variables from the open vlsv file.</span>
<span class="sd">       Arguments:</span>
<span class="sd">       :param name: Name of the variable</span>
<span class="sd">       :param operator: Datareduction operator. &quot;pass&quot; does no operation on data</span>
<span class="sd">       :returns: numpy array with the data in node order</span>

<span class="sd">       ... seealso:: :func:`read_variable`</span>
<span class="sd">       &#39;&#39;&#39;</span>
       <span class="c1"># Read the raw array data</span>
       <span class="n">rawData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s1">&#39;ionosphere&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;VARIABLE&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>

       <span class="k">return</span> <span class="n">rawData</span></div>



<div class="viewcode-block" id="VlsvReader.read_variable_from_cache">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_variable_from_cache">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_variable_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cellids</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read variable from cache instead of the vlsv file.</span>
<span class="sd">         :param name: Name of the variable</span>
<span class="sd">         :param cellids: a value of -1 reads all data</span>
<span class="sd">         :param operator: Datareduction operator. &quot;pass&quot; does no operation on data</span>
<span class="sd">         :returns: numpy array with the data, same format as read_variable</span>

<span class="sd">         .. seealso:: :func:`read_variable`</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="n">var_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_cache</span><span class="p">[(</span><span class="n">name</span><span class="p">,</span><span class="n">operator</span><span class="p">)]</span>
      <span class="k">if</span> <span class="n">var_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
         <span class="n">value_len</span> <span class="o">=</span> <span class="n">var_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">value_len</span> <span class="o">=</span> <span class="mi">1</span>
         
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cellids</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
         <span class="k">if</span> <span class="n">cellids</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var_data</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span><span class="p">[</span><span class="n">cellids</span><span class="p">]]</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="n">cellids</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">value_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var_data</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var_data</span><span class="p">[</span><span class="n">indices</span><span class="p">,:]</span></div>

         
         
<div class="viewcode-block" id="VlsvReader.read_variable_to_cache">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_variable_to_cache">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_variable_to_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read variable from vlsv file to cache, for the whole grid and after applying</span>
<span class="sd">          operator.</span>
<span class="sd">          :param name: Name of the variable (or datareducer)</span>
<span class="sd">          :param operator: Datareduction operator. &quot;pass&quot; does no operation on data.</span>

<span class="sd">      &#39;&#39;&#39;</span>

      <span class="c1"># add data to dict, use a tuple of (name,operator) as the key [tuples are immutable and hashable]</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">variable_cache</span><span class="p">[(</span><span class="n">name</span><span class="p">,</span><span class="n">operator</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
      <span class="c1"># Also initialize the fileindex dict at the same go because it is very likely something you want to have for accessing cached values</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__read_fileindex_for_cellid</span><span class="p">()</span></div>


<div class="viewcode-block" id="VlsvReader.read_variable">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_variable">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read variables from the open vlsv file. </span>
<span class="sd">      Arguments:</span>
<span class="sd">      :param name: Name of the variable</span>
<span class="sd">      :param cellids: a value of -1 reads all data</span>
<span class="sd">      :param operator: Datareduction operator. &quot;pass&quot; does no operation on data</span>
<span class="sd">      :returns: numpy array with the data</span>

<span class="sd">      .. seealso:: :func:`read` :func:`read_variable_info`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">cellids</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span>

      <span class="c1"># Wrapper, check if requesting an fsgrid variable</span>
      <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">check_variable</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;fg_&quot;</span><span class="p">)):</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">cellids</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span> <span class="s2">&quot;CellID requests not supported for FSgrid variables! Aborting.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_fsgrid_variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>

      <span class="c1">#if(self.check_variable(name) and (name.lower()[0:3]==&quot;ig_&quot;)):</span>
      <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;ig_&quot;</span><span class="p">:</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">cellids</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;CellID requests not supported for ionosphere variables! Aborting.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_ionosphere_variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
      
      <span class="k">if</span><span class="p">((</span><span class="n">name</span><span class="p">,</span><span class="n">operator</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_cache</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable_from_cache</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">cellids</span><span class="p">,</span><span class="n">operator</span><span class="p">)</span>

      <span class="c1"># Passes the list of cell id&#39;s onwards - optimization for reading is done in the lower level read() method</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;VARIABLE&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=</span><span class="n">cellids</span><span class="p">)</span></div>


<div class="viewcode-block" id="VlsvReader.read_variable_info">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_variable_info">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_variable_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read variables from the open vlsv file and input the data into VariableInfo</span>

<span class="sd">      :param name: Name of the variable</span>
<span class="sd">      :param cellids: a value of -1 reads all data</span>
<span class="sd">      :param operator: Datareduction operator. &quot;pass&quot; does no operation on data</span>
<span class="sd">      :returns: numpy array with the data</span>

<span class="sd">      .. seealso:: :func:`read_variable`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="kn">from</span><span class="w"> </span><span class="nn">analysator.calculations.variable</span><span class="w"> </span><span class="kn">import</span> <span class="n">VariableInfo</span>

      <span class="c1"># Force lowercase</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

      <span class="c1"># Get population and variable names from data array name </span>
      <span class="k">if</span> <span class="s1">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
         <span class="n">popname</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
         <span class="k">if</span> <span class="n">popname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_populations</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">popname</span> <span class="o">=</span> <span class="s1">&#39;pop&#39;</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="n">name</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">popname</span> <span class="o">=</span> <span class="s2">&quot;pop&quot;</span>
         <span class="n">varname</span> <span class="o">=</span> <span class="n">name</span>

      <span class="c1"># Check which set of datareducers to use</span>
      <span class="k">if</span> <span class="n">varname</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;vg_&quot;</span> <span class="ow">or</span> <span class="n">varname</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;ig_&quot;</span><span class="p">:</span>
         <span class="n">reducer_reg</span> <span class="o">=</span> <span class="n">v5reducers</span>
         <span class="n">reducer_multipop</span> <span class="o">=</span> <span class="n">multipopv5reducers</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">reducer_reg</span> <span class="o">=</span> <span class="n">datareducers</span>
         <span class="n">reducer_multipop</span> <span class="o">=</span> <span class="n">multipopdatareducers</span>

      <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">check_variable</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">varname</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;vg_&quot;</span> <span class="ow">or</span> <span class="n">varname</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;fg_&quot;</span> <span class="ow">or</span> <span class="n">varname</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;ig_&quot;</span><span class="p">)):</span>
         <span class="c1"># For Vlasiator 5 vlsv files, metadata is included</span>
         <span class="n">units</span><span class="p">,</span> <span class="n">latexunits</span><span class="p">,</span> <span class="n">latex</span><span class="p">,</span> <span class="n">conversion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_metadata</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
         <span class="c1"># Correction for early version incorrect number density (extra backslash)</span>
         <span class="k">if</span> <span class="n">latex</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="sa">r</span><span class="s2">&quot;$\n&quot;</span><span class="p">:</span>
            <span class="n">latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$n&quot;</span><span class="o">+</span><span class="n">latex</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
      <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">check_variable</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">unitsdict</span><span class="p">)):</span>
         <span class="n">units</span> <span class="o">=</span> <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">unitsdict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
         <span class="n">latex</span> <span class="o">=</span> <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">latexdict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
         <span class="n">latexunits</span> <span class="o">=</span> <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">latexunitsdict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>            
      <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">reducer_reg</span><span class="p">:</span>
         <span class="n">units</span> <span class="o">=</span> <span class="n">reducer_reg</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">units</span>
         <span class="n">latex</span> <span class="o">=</span> <span class="n">reducer_reg</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">latex</span>
         <span class="n">latexunits</span> <span class="o">=</span> <span class="n">reducer_reg</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">latexunits</span>
      <span class="k">elif</span> <span class="s1">&#39;pop/&#39;</span><span class="o">+</span><span class="n">varname</span> <span class="ow">in</span> <span class="n">reducer_multipop</span><span class="p">:</span>
         <span class="n">poplatex</span><span class="o">=</span><span class="s1">&#39;i&#39;</span>
         <span class="k">if</span> <span class="n">popname</span> <span class="ow">in</span> <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">speciesdict</span><span class="p">:</span>
            <span class="n">poplatex</span> <span class="o">=</span> <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">speciesdict</span><span class="p">[</span><span class="n">popname</span><span class="p">]</span>
         <span class="n">units</span> <span class="o">=</span> <span class="n">reducer_multipop</span><span class="p">[</span><span class="s1">&#39;pop/&#39;</span><span class="o">+</span><span class="n">varname</span><span class="p">]</span><span class="o">.</span><span class="n">units</span>
         <span class="n">latex</span> <span class="o">=</span> <span class="p">(</span><span class="n">reducer_multipop</span><span class="p">[</span><span class="s1">&#39;pop/&#39;</span><span class="o">+</span><span class="n">varname</span><span class="p">]</span><span class="o">.</span><span class="n">latex</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;REPLACEPOP&#39;</span><span class="p">,</span><span class="n">poplatex</span><span class="p">)</span>
         <span class="n">latexunits</span> <span class="o">=</span> <span class="n">reducer_multipop</span><span class="p">[</span><span class="s1">&#39;pop/&#39;</span><span class="o">+</span><span class="n">varname</span><span class="p">]</span><span class="o">.</span><span class="n">latexunits</span>
      <span class="k">elif</span> <span class="n">varname</span> <span class="ow">in</span> <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">unitsdict</span><span class="p">:</span>
         <span class="n">poplatex</span><span class="o">=</span><span class="s1">&#39;i&#39;</span>
         <span class="k">if</span> <span class="n">popname</span> <span class="ow">in</span> <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">speciesdict</span><span class="p">:</span>
            <span class="n">poplatex</span> <span class="o">=</span> <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">speciesdict</span><span class="p">[</span><span class="n">popname</span><span class="p">]</span>
         <span class="n">units</span> <span class="o">=</span> <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">unitsdict</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span>
         <span class="n">latex</span> <span class="o">=</span> <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">latexdictmultipop</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;REPLACEPOP&#39;</span><span class="p">,</span><span class="n">poplatex</span><span class="p">)</span>
         <span class="n">latexunits</span> <span class="o">=</span> <span class="n">vlsvvariables</span><span class="o">.</span><span class="n">latexunitsdict</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">units</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
         <span class="n">latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;</span><span class="o">+</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;_&quot;</span><span class="p">,</span><span class="sa">r</span><span class="s2">&quot;\_&quot;</span><span class="p">)</span>
         <span class="n">latexunits</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

      <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;fg_&#39;</span><span class="p">):</span>
          <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_fsgrid_variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ig_&#39;</span><span class="p">):</span>
          <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_ionosphere_variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=</span><span class="n">cellids</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">operator</span> <span class="o">!=</span> <span class="s2">&quot;pass&quot;</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">operator</span><span class="o">==</span><span class="s2">&quot;magnitude&quot;</span><span class="p">:</span>
            <span class="n">latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$|$&quot;</span><span class="o">+</span><span class="n">latex</span><span class="o">+</span><span class="sa">r</span><span class="s2">&quot;$|$&quot;</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">latex</span> <span class="o">=</span> <span class="n">latex</span><span class="o">+</span><span class="sa">r</span><span class="s2">&quot;${_{&quot;</span><span class="o">+</span><span class="n">operator</span><span class="o">+</span><span class="sa">r</span><span class="s2">&quot;}}$&quot;</span>
         <span class="k">return</span> <span class="n">VariableInfo</span><span class="p">(</span><span class="n">data_array</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">operator</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="n">latex</span><span class="p">,</span> <span class="n">latexunits</span><span class="o">=</span><span class="n">latexunits</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">VariableInfo</span><span class="p">(</span><span class="n">data_array</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="n">latex</span><span class="p">,</span> <span class="n">latexunits</span><span class="o">=</span><span class="n">latexunits</span><span class="p">)</span></div>



<div class="viewcode-block" id="VlsvReader.get_max_refinement_level">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_max_refinement_level">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_max_refinement_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns the maximum refinement level of the AMR</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_spatial_amr_level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
         <span class="c1"># Read the file index for cellid</span>
         <span class="n">cellids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;CellID&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;VARIABLE&quot;</span><span class="p">)</span>
         <span class="n">maxcellid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span><span class="n">cellids</span><span class="p">]))</span>

         <span class="n">AMR_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
         <span class="k">while</span> <span class="p">(</span><span class="n">maxcellid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">maxcellid</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">AMR_count</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__zcells</span><span class="p">)</span>
            <span class="n">AMR_count</span> <span class="o">+=</span> <span class="mi">1</span>
            
         <span class="bp">self</span><span class="o">.</span><span class="n">__max_spatial_amr_level</span> <span class="o">=</span> <span class="n">AMR_count</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__max_spatial_amr_level</span></div>


<div class="viewcode-block" id="VlsvReader.get_amr_level">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_amr_level">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_amr_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cellid</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Returns the AMR level of a given cell defined by its cellid</span>
<span class="sd">      </span>
<span class="sd">      :param cellid:        The cell&#39;s cellid</span>
<span class="sd">      :returns:             The cell&#39;s refinement level in the AMR</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">stack</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cellid</span><span class="p">,</span><span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
         <span class="n">cellid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
         <span class="n">stack</span> <span class="o">=</span> <span class="kc">False</span>

      <span class="n">AMR_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
      <span class="n">cellids</span> <span class="o">=</span> <span class="n">cellid</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
      <span class="n">iters</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cellids</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
         <span class="n">mask</span> <span class="o">=</span> <span class="n">cellids</span> <span class="o">&gt;</span> <span class="mi">0</span>
         <span class="n">sub</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">AMR_count</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__zcells</span><span class="p">)</span>
         <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">cellids</span><span class="p">,</span> <span class="n">sub</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="n">out</span> <span class="o">=</span> <span class="n">cellids</span><span class="p">,</span> <span class="n">where</span> <span class="o">=</span> <span class="n">mask</span><span class="p">)</span>
         <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">AMR_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">AMR_count</span><span class="p">,</span> <span class="n">where</span> <span class="o">=</span> <span class="n">mask</span><span class="p">)</span>
         <span class="n">iters</span> <span class="o">=</span> <span class="n">iters</span><span class="o">+</span><span class="mi">1</span>
         <span class="k">if</span><span class="p">(</span><span class="n">iters</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_max_refinement_level</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Can&#39;t have that large refinements. Something broke.&quot;</span><span class="p">)</span>
            <span class="k">break</span>

      <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">AMR_count</span> <span class="o">-</span> <span class="mi">1</span> 
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="p">(</span><span class="n">AMR_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="VlsvReader.get_cell_dx">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_cell_dx">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_cell_dx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellid</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Returns the dx of a given cell defined by its cellid</span>
<span class="sd">      </span>
<span class="sd">      :param cellid:        The cell&#39;s cellid</span>
<span class="sd">      :returns:             The cell&#39;s size [dx, dy, dz]</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="n">stack</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cellid</span><span class="p">,</span><span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
         <span class="n">cellid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
         <span class="n">stack</span> <span class="o">=</span> <span class="kc">False</span>

      <span class="n">cellid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cellid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

      <span class="n">dxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">__dx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">__dy</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">__dz</span><span class="p">]])</span>

      <span class="n">dxs</span> <span class="o">=</span> <span class="n">dxs</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">cellid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

      <span class="n">amrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_amr_level</span><span class="p">(</span><span class="n">cellid</span><span class="p">)])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
      <span class="n">amrs</span> <span class="o">=</span> <span class="n">amrs</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">amrs</span><span class="p">[</span><span class="n">amrs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

      <span class="n">ret</span> <span class="o">=</span> <span class="n">dxs</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">amrs</span>

      <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">ret</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="VlsvReader.get_cell_bbox">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_cell_bbox">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_cell_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellid</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Returns the bounding box of a given cell defined by its cellid</span>
<span class="sd">      </span>
<span class="sd">      :param cellid:        The cell&#39;s cellid</span>
<span class="sd">      :returns:             The cell&#39;s bbox [xmin,ymin,zmin],[xmax,ymax,zmax]</span>
<span class="sd">      &#39;&#39;&#39;</span>
      
      <span class="n">hdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_dx</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span>
      <span class="n">mid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_coordinates</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">mid</span><span class="o">-</span><span class="n">hdx</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="n">hdx</span></div>


<div class="viewcode-block" id="VlsvReader.get_cell_fsgrid_slicemap">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_cell_fsgrid_slicemap">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_cell_fsgrid_slicemap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellid</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Returns a slice tuple of fsgrid indices that are contained in the SpatialGrid</span>
<span class="sd">      cell.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">low</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_bbox</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
      <span class="n">lowi</span><span class="p">,</span> <span class="n">upi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_slice_indices</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">up</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">lowi</span><span class="p">,</span> <span class="n">upi</span></div>


<div class="viewcode-block" id="VlsvReader.get_bbox_fsgrid_slicemap">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_bbox_fsgrid_slicemap">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_bbox_fsgrid_slicemap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">up</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Returns a slice tuple of fsgrid indices that are contained in the (low, up) bounding box.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">lowi</span><span class="p">,</span> <span class="n">upi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_slice_indices</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">up</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">lowi</span><span class="p">,</span> <span class="n">upi</span></div>


<div class="viewcode-block" id="VlsvReader.get_cell_fsgrid_subarray">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_cell_fsgrid_subarray">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_cell_fsgrid_subarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellid</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Returns a subarray of the fsgrid array, corresponding to the fsgrid</span>
<span class="sd">      covered by the SpatialGrid cellid.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">lowi</span><span class="p">,</span> <span class="n">upi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_fsgrid_slicemap</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
      <span class="n">fssize</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_size</span><span class="p">())</span>
      <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">fssize</span><span class="p">:</span>
         <span class="c1">#expand to have a singleton dimension for a reduced dim - lets slicing happen with ease</span>
         <span class="n">singletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fssize</span><span class="p">)</span> <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
         <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">singletons</span><span class="p">:</span>
            <span class="n">array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
         <span class="n">ret</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">lowi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">lowi</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">lowi</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">ret</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">lowi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">lowi</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">lowi</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
      <span class="n">array</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
      <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="VlsvReader.get_bbox_fsgrid_subarray">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_bbox_fsgrid_subarray">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_bbox_fsgrid_subarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Returns a subarray of the fsgrid array, corresponding to the (low, up) bounding box.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">lowi</span><span class="p">,</span> <span class="n">upi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bbox_fsgrid_slicemap</span><span class="p">(</span><span class="n">low</span><span class="p">,</span><span class="n">up</span><span class="p">)</span>
      <span class="n">fssize</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_size</span><span class="p">())</span>
      <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">fssize</span><span class="p">:</span>
         <span class="c1">#expand to have a singleton dimension for a reduced dim - lets slicing happen with ease</span>
         <span class="n">singletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fssize</span><span class="p">)</span> <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
         <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">singletons</span><span class="p">:</span>
            <span class="n">array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
         <span class="n">ret</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">lowi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">lowi</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">lowi</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">ret</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">lowi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">lowi</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">lowi</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

      <span class="n">array</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
      <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="VlsvReader.downsample_fsgrid_subarray">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.downsample_fsgrid_subarray">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">downsample_fsgrid_subarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellid</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Returns a mean value of fsgrid values underlying the SpatialGrid cellid.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">fsarr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_fsgrid_subarray</span><span class="p">(</span><span class="n">cellid</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>
      
      <span class="n">n</span> <span class="o">=</span> <span class="n">fsarr</span><span class="o">.</span><span class="n">size</span>
      <span class="k">if</span> <span class="n">fsarr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
         <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">3</span>
      <span class="n">ncells</span> <span class="o">=</span> <span class="mi">8</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_refinement_level</span><span class="p">()</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">get_amr_level</span><span class="p">(</span><span class="n">cellid</span><span class="p">))</span>
      <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">ncells</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Weird fs subarray size &quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">+</span> <span class="s1">&#39; for amrlevel &#39;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_amr_level</span><span class="p">(</span><span class="n">cellid</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; expect &#39;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ncells</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fsarr</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="VlsvReader.fsgrid_array_to_vg">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.fsgrid_array_to_vg">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">fsgrid_array_to_vg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Downsample, via averaging, an fsgrid array to the Vlasov grid</span>
<span class="sd">      of this reader.</span>

<span class="sd">      :param array:  array with first three dimensions corresponding to the</span>
<span class="sd">                     dimensions of the fsgrid associated with this reader.</span>
<span class="sd">      :returns: Vlasov grid data (in file order) of array averaged to Vlasov Grid.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">cellIds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="s2">&quot;CellID&quot;</span><span class="p">)</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">map_vg_onto_fg</span><span class="p">()</span>
      <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
      <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
         <span class="n">numel</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
         <span class="n">vgarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">cellIds</span><span class="p">),</span><span class="n">numel</span><span class="p">))</span>
         <span class="n">reshaped_mapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numel</span><span class="p">):</span>
            <span class="n">wgts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="p">[:,:,:,</span><span class="n">i</span><span class="p">],</span><span class="n">array</span><span class="p">[:,:,:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">reshaped_mapping</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">wgts</span><span class="p">)</span>
            <span class="n">vgarr</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">sums</span><span class="p">,</span><span class="n">counts</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">array</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
         <span class="n">vgarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">sums</span><span class="p">,</span><span class="n">counts</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">vgarr</span></div>


   <span class="k">def</span><span class="w"> </span><span class="nf">vg_uniform_grid_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">exprtuple</span><span class="p">):</span>
      <span class="n">cellIds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="s2">&quot;CellID&quot;</span><span class="p">)</span>
      <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable_as_fg</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
      <span class="n">array</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="o">*</span><span class="n">exprtuple</span><span class="p">)</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fsgrid_array_to_vg</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">get_cellid_at_fsgrid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
      <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_coordinates</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">])</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cellid</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

<div class="viewcode-block" id="VlsvReader.upsample_fsgrid_subarray">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.upsample_fsgrid_subarray">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">upsample_fsgrid_subarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellid</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Set the elements of the fsgrid array to the value of corresponding SpatialGrid</span>
<span class="sd">      cellid. Mutator for array.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">lowi</span><span class="p">,</span> <span class="n">upi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_fsgrid_slicemap</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
      <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=</span><span class="p">[</span><span class="n">cellid</span><span class="p">])</span>
      <span class="n">fssize</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_size</span><span class="p">())</span>
      <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">fssize</span><span class="p">:</span>
         <span class="c1">#expand to have a singleton dimension for a reduced dim - lets slicing happen with ease</span>
         <span class="n">singletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fssize</span><span class="p">)</span> <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
         <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">singletons</span><span class="p">:</span>
            <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
            <span class="n">array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
         
      <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
         <span class="n">array</span><span class="p">[</span><span class="n">lowi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">lowi</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">lowi</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">value</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">array</span><span class="p">[</span><span class="n">lowi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">lowi</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">lowi</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">upi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
      <span class="n">value</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
      <span class="n">array</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
      <span class="k">return</span></div>


   <span class="k">def</span><span class="w"> </span><span class="nf">read_variable_as_fg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s1">&#39;pass&#39;</span><span class="p">):</span>
      <span class="n">vg_cellids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="s1">&#39;CellID&#39;</span><span class="p">)</span>
      <span class="n">sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_size</span><span class="p">()</span>
      <span class="n">sz_amr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_mesh_size</span><span class="p">()</span>
      <span class="n">vg_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
      <span class="n">varsize</span> <span class="o">=</span> <span class="n">vg_var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
      <span class="k">if</span><span class="p">(</span><span class="n">varsize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
         <span class="n">fg_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">sz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">varsize</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vg_var</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">fg_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vg_var</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">map_vg_onto_fg</span><span class="p">()</span>
      <span class="n">fg_var</span> <span class="o">=</span> <span class="n">vg_var</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">fg_var</span>


   <span class="c1"># Builds fsgrid array that contains indices to the SpatialGrid data that are colocated with the fsgrid cells.</span>
   <span class="c1"># Many fsgrid cells may map to the same index of SpatialGrid data.</span>
   <span class="c1"># Example: for fsgrid cell at indices [i,j,k], find the overlaying SpatialGrid cell by:</span>
   <span class="c1"># vg_overlaying_CellID_at_ijk = self.read_variable(&#39;CellID&#39;)[self.__vg_indexes_on_fg[i,j,k]]</span>
   <span class="c1"># or, for all fsgrid cells:</span>
   <span class="c1"># vg_CellIDs_on_fg = self.read_variable(&#39;CellID&#39;)[self.__vg_indexes_on_fg]</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">map_vg_onto_fg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
         <span class="n">vg_cellids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="s1">&#39;CellID&#39;</span><span class="p">)</span>
         <span class="n">sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_size</span><span class="p">()</span>
         <span class="n">sz_amr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_mesh_size</span><span class="p">()</span>
         <span class="n">max_amr_level</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sz_amr</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1000000000</span> <span class="c1"># big number to catch errors in the latter code, 0 is not good for that</span>
         <span class="n">amr_levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_amr_level</span><span class="p">(</span><span class="n">vg_cellids</span><span class="p">)</span>
         <span class="n">cell_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell_indices</span><span class="p">(</span><span class="n">vg_cellids</span><span class="p">,</span><span class="n">amr_levels</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
         <span class="n">refined_ids_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell_indices</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">max_amr_level</span><span class="o">-</span><span class="n">amr_levels</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
         <span class="n">refined_ids_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">refined_ids_start</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">max_amr_level</span><span class="o">-</span><span class="n">amr_levels</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            
         <span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span> <span class="o">=</span> <span class="n">map_vg_onto_fg_loop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span><span class="p">,</span><span class="n">vg_cellids</span><span class="p">,</span> <span class="n">refined_ids_start</span><span class="p">,</span> <span class="n">refined_ids_end</span><span class="p">)</span>

      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vg_indexes_on_fg</span>

<div class="viewcode-block" id="VlsvReader.get_cell_fsgrid">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_cell_fsgrid">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_cell_fsgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellid</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Returns a slice tuple of fsgrid indices that are contained in the SpatialGrid</span>
<span class="sd">      cell.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">low</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_bbox</span><span class="p">(</span><span class="n">cellid</span><span class="p">)</span>
      <span class="n">lowi</span><span class="p">,</span> <span class="n">upi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_slice_indices</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">up</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">lowi</span><span class="p">,</span> <span class="n">upi</span></div>


<div class="viewcode-block" id="VlsvReader.get_fsgrid_coordinates">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_fsgrid_coordinates">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_fsgrid_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ri</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Returns real-space center coordinates of the fsgrid 3-index.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">lowerlimit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_extent</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
      <span class="n">dxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_cell_size</span><span class="p">()</span>

      <span class="k">return</span> <span class="n">lowerlimit</span><span class="o">+</span><span class="n">dxs</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span></div>


<div class="viewcode-block" id="VlsvReader.get_unique_cellids">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_unique_cellids">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_unique_cellids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns a list of cellids containing all the coordinates in coords,</span>
<span class="sd">          with no duplicate cellids. Relative order of elements is conserved.</span>

<span class="sd">      :param coords:         A list of coordinates</span>

<span class="sd">      :returns: a list of unique cell ids</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="c1"># cids = [int(self.get_cellid(coord)) for coord in coords]</span>
      <span class="n">cids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cellid</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

      <span class="c1">#choose unique cids, keep ordering. This requires a bit of OrderedDict magic (python 2.7+)</span>
      <span class="n">cidsout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">cids</span><span class="p">)))</span>
      <span class="k">return</span> <span class="n">cidsout</span></div>

   
<div class="viewcode-block" id="VlsvReader.get_cellid">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_cellid">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_cellid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns the cell ids at given coordinates</span>

<span class="sd">      :param coords:        The cells&#39; coordinates</span>
<span class="sd">      :returns: the cell ids</span>

<span class="sd">      .. note:: Returns 0 if the cellid is out of bounds!</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="n">stack</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
         <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
         <span class="n">stack</span> <span class="o">=</span> <span class="kc">False</span>

      <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Coordinates are required to be 3-dimensional (coords were </span><span class="si">%d</span><span class="s2">-dimensional)&quot;</span> <span class="o">%</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

      <span class="c1"># If needed, read the file index for cellid</span>
      <span class="c1"># if len(self.__fileindex_for_cellid) == 0:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__read_fileindex_for_cellid</span><span class="p">()</span>
      <span class="c1">#good_ids = self.read_variable(&quot;CellID&quot;)</span>
      <span class="c1"># good_ids = np.array(list(self.__fileindex_for_cellid.keys()))</span>
      <span class="c1"># good_ids.sort()</span>

      <span class="n">cellids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

      <span class="c1"># mask for cells that are unresolved - out-of-bounds coordinates stay at zero</span>
      <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__xmax</span> <span class="o">&gt;</span> <span class="n">coordinates</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__xmin</span> <span class="o">&lt;</span> <span class="n">coordinates</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span>
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ymax</span> <span class="o">&gt;</span> <span class="n">coordinates</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ymin</span> <span class="o">&lt;</span> <span class="n">coordinates</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__zmax</span> <span class="o">&gt;</span> <span class="n">coordinates</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__zmin</span> <span class="o">&lt;</span> <span class="n">coordinates</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
      <span class="p">)</span>

      <span class="c1"># Get cell lengths:</span>
      <span class="n">cell_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dz</span><span class="p">])</span>

      <span class="n">cellindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
      
      

      <span class="c1"># Get cell indices:</span>
      <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xmin</span><span class="p">)</span><span class="o">/</span><span class="n">cell_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ymin</span><span class="p">)</span><span class="o">/</span><span class="n">cell_lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__zmin</span><span class="p">)</span><span class="o">/</span><span class="n">cell_lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
      <span class="c1"># Get the cell id:</span>
      <span class="n">cellids</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span> <span class="o">+</span> <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span> <span class="o">+</span> <span class="mi">1</span>

      <span class="c1"># Going through AMR levels as needed</span>
      <span class="n">AMR_count</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">ncells_lowerlevel</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">refmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_max_refinement_level</span><span class="p">()</span>


      <span class="k">while</span> <span class="n">AMR_count</span> <span class="o">&lt;</span> <span class="n">refmax</span> <span class="o">+</span><span class="mi">1</span><span class="p">:</span>
         <span class="n">drop</span> <span class="o">=</span> <span class="o">~</span><span class="n">dict_keys_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span><span class="p">,</span> <span class="n">cellids</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>

         <span class="n">mask</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">drop</span>
         
         <span class="n">ncells_lowerlevel</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">AMR_count</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__zcells</span><span class="p">)</span> <span class="c1"># Increment of cellID from lower lvl             </span>
         <span class="n">AMR_count</span> <span class="o">+=</span> <span class="mi">1</span>
         <span class="c1"># Get cell lengths:</span>
         <span class="n">cell_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dz</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="n">AMR_count</span> <span class="c1"># Check next AMR level</span>

         <span class="c1"># Get cell indices:</span>
         <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xmin</span><span class="p">)</span><span class="o">/</span><span class="n">cell_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
         <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ymin</span><span class="p">)</span><span class="o">/</span><span class="n">cell_lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
         <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__zmin</span><span class="p">)</span><span class="o">/</span><span class="n">cell_lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
         <span class="c1"># Get the cell id:</span>
         <span class="n">cellids</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncells_lowerlevel</span> <span class="o">+</span> <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">AMR_count</span><span class="p">)</span><span class="o">*</span><span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span> <span class="o">+</span> <span class="mi">4</span><span class="o">**</span><span class="p">(</span><span class="n">AMR_count</span><span class="p">)</span> <span class="o">*</span> <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span> <span class="o">+</span> <span class="mi">1</span>

      <span class="n">drop</span> <span class="o">=</span> <span class="o">~</span><span class="n">dict_keys_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span><span class="p">,</span> <span class="n">cellids</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
      <span class="n">mask</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">drop</span>
      <span class="n">cellids</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># set missing cells to null cell</span>
      <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">cellids</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">cellids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="VlsvReader.get_cellid_with_vdf">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_cellid_with_vdf">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_cellid_with_vdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">pop</span> <span class="o">=</span> <span class="s1">&#39;proton&#39;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns the cell ids nearest to test points, that contain VDFs</span>

<span class="sd">      :param coords:    Test coordinates [meters] of N_in points in ND-dimensional space</span>
<span class="sd">                        array with shape [N_in, ND] or [ND]</span>

<span class="sd">      Example: cellid = vlsvReader.get_cellid_with_vdf(np.array([1e8, 0, 0]))</span>
<span class="sd">      :returns: the cell ids</span>

<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">stack</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="n">coords_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_in</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
         <span class="n">coords_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">coords_in</span><span class="p">)</span>
         <span class="n">stack</span> <span class="o">=</span> <span class="kc">False</span>

      <span class="k">if</span> <span class="ow">not</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cells_with_blocks</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__set_cell_offset_and_blocks_nodict</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="n">cid_w_vdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cells_with_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span>
      <span class="n">coords_w_vdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_coordinates</span><span class="p">(</span><span class="n">cid_w_vdf</span><span class="p">)</span>
      <span class="n">N_in</span> <span class="o">=</span> <span class="n">coords_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">N_w_vdf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cid_w_vdf</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">N_w_vdf</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error: No velocity distributions found!&quot;</span><span class="p">)</span>


      <span class="c1"># Boolean array flag_empty_in indicates if queried points (coords_in) don&#39;t already lie within vdf-containing cells, </span>
      <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cellid</span><span class="p">(</span><span class="n">coords_in</span><span class="p">)</span>
      <span class="n">flag_empty_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">cid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__order_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span> <span class="k">for</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span> <span class="p">)</span>
      <span class="n">N_empty_in</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">flag_empty_in</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">N_empty_in</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># every element of coords_in already within a vdf-containing cell</span>
         <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      
      <span class="c1"># Direct search: calculate distances for each pair points (test &lt;--&gt; vdf cells)</span>
      <span class="c1"># Only calculate nearest distance if there is no VDF already in the cell (using flag_empty_in) </span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">      try:</span>
<span class="sd">         # Vectorized approach: </span>
<span class="sd">         dist2 = np.nansum((coords_in[flag_empty_in, None, :] - coords_w_vdf[None, :, :])**2, axis = -1)   # distance^2, shape [N_empty_in, N_w_vdf]</span>
<span class="sd">         output[flag_empty_in] = cid_w_vdf[np.argmin(dist2, axis = 1)]</span>
<span class="sd">      except MemoryError:</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="c1"># Loop approach:</span>
      <span class="c1"># logging.info(&#39;Not enough memory to broadcast arrays! Using a loop instead...&#39;)</span>
      <span class="n">ind_emptycell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flag_empty_in</span><span class="p">))[</span><span class="n">flag_empty_in</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">ind_emptycell</span><span class="p">:</span>
         <span class="n">this_coord</span> <span class="o">=</span> <span class="n">coords_in</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:]</span>
         <span class="n">dist2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">((</span><span class="n">coords_w_vdf</span> <span class="o">-</span> <span class="n">this_coord</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
         <span class="n">output</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">cid_w_vdf</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist2</span><span class="p">)]</span>

      <span class="c1"># return cells that minimize the distance to the test points</span>
      <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">output</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

      
<div class="viewcode-block" id="VlsvReader.cellid_has_vdf">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.cellid_has_vdf">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">cellid_has_vdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cid</span><span class="p">,</span> <span class="n">pop</span> <span class="o">=</span> <span class="s1">&#39;proton&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">bool</span><span class="p">:</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns whether the cid in question has a vdf or not</span>
<span class="sd">      :param coords:    the cellid to test for</span>
<span class="sd">      :returns: bool </span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__set_cell_offset_and_blocks_nodict</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="n">cid_w_vdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cells_with_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">cid_w_vdf</span></div>


<div class="viewcode-block" id="VlsvReader.get_vertex_indices">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_vertex_indices">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_vertex_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Get dual grid vertex indices for all coordinates.</span>
<span class="sd">      </span>
<span class="sd">      Works by truncation to integer indices at fsgrid resolution, for cell low-corners.</span>
<span class="sd">      :param coordinates: np.array of coordinates, shaped either (3,) or (N,3)</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
      <span class="n">stack</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
         <span class="n">stack</span> <span class="o">=</span> <span class="kc">False</span>
         <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
      <span class="n">cell_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dz</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_refinement_level</span><span class="p">()</span>
      <span class="n">extents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_extent</span><span class="p">()</span>
      <span class="n">mins</span> <span class="o">=</span> <span class="n">extents</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
      <span class="n">maxs</span> <span class="o">=</span> <span class="n">extents</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
      <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cell_lengths</span><span class="p">)</span><span class="o">/</span><span class="mi">1000</span>
      <span class="n">crds</span> <span class="o">=</span> <span class="n">coordinates</span> <span class="o">-</span> <span class="n">mins</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">eps</span>
      <span class="n">indices</span> <span class="o">=</span> <span class="n">crds</span><span class="o">/</span><span class="n">cell_lengths</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
      <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
         <span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
         <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span></div>

      
<div class="viewcode-block" id="VlsvReader.get_vertex_coordinates_from_indices">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_vertex_coordinates_from_indices">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_vertex_coordinates_from_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Convert vertex indices to physical coordinates.</span>
<span class="sd">      :param indices: numpy array of vertex indices, either (3,) or (N,3)</span>

<span class="sd">      :returns: numpy array of coordinates, with matching shape to indices</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">stack</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
      <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
         <span class="n">stack</span> <span class="o">=</span> <span class="kc">False</span>
         <span class="n">inds</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
      <span class="n">cell_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dz</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_refinement_level</span><span class="p">()</span>
      <span class="n">extents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_extent</span><span class="p">()</span>
      <span class="n">mins</span> <span class="o">=</span> <span class="n">extents</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
      <span class="n">crds</span> <span class="o">=</span> <span class="n">inds</span><span class="o">*</span><span class="n">cell_lengths</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
      <span class="n">crds</span> <span class="o">=</span> <span class="n">crds</span> <span class="o">+</span> <span class="n">mins</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>

      <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">crds</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">crds</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span></div>


   <span class="c1"># this should then do the proper search instead of intp for in which dual of the cell the point lies</span>
<div class="viewcode-block" id="VlsvReader.get_dual">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_dual">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_dual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">cellids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Find the duals that contain the coordinate points pts. This will call the iterative find_ksi function</span>
<span class="sd">      to see if the resulting interpolation weights for the coordinate are in the range [0,1]; if not, it will iterate </span>
<span class="sd">      through neighbouring duals until a dual is found.</span>
<span class="sd">      :parameter pts: numpy array of coordinates (N,3)</span>

<span class="sd">      :returns: duals (numpy array of N 3-tuples), ksis (numpy array of interpolation weights (N, 8))</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="kn">from</span><span class="w"> </span><span class="nn">analysator.calculations.interpolator_amr</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_ksi</span>

      <span class="c1"># start the search from the vertices </span>
      <span class="k">if</span> <span class="n">cellids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="n">cid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cellid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">cid</span> <span class="o">=</span> <span class="n">cellids</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">build_cell_vertices</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">cid</span><span class="p">),</span><span class="n">prune_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      
      <span class="n">vverts</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__cell_vertices</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cid</span><span class="p">]</span>
      <span class="n">set_of_verts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
      <span class="c1"># Loops over duals indexed by vertex tuple</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">build_dual_from_vertices</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set_of_verts</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">vverts</span><span class="p">)))</span>

      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">verts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vverts</span><span class="p">):</span>
         <span class="n">bboxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="n">verts</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dual_bboxes</span><span class="p">))</span>
         <span class="n">vmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">&gt;=</span> <span class="n">bboxes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">&lt;=</span> <span class="n">bboxes</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
         <span class="n">okverts</span> <span class="o">=</span> <span class="p">[</span><span class="n">verts</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vmask</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span><span class="p">]</span>
         <span class="n">vverts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">okverts</span>

      <span class="c1"># Breaks degeneracies by expanding the dual cells vertices along</span>
      <span class="c1">#  main-grid diagonals</span>
      <span class="n">offset_eps</span> <span class="o">=</span> <span class="mf">1.0</span>
      <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">],</span>
                           <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span>
                           <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">],</span>
                           <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span>
                           <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">],</span>
                        <span class="p">])</span> <span class="o">*</span> <span class="n">offset_eps</span>

      <span class="n">verts_per_pt</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="k">for</span> <span class="n">verts</span> <span class="ow">in</span> <span class="n">vverts</span><span class="p">]</span>
      <span class="n">ppts</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">verts_per_pt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">pinds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">verts_per_pt</span><span class="p">)</span>

      <span class="n">all_verts</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">vverts</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">]</span>

      <span class="n">all_vcoords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_coordinates</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="n">all_verts</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dual_cells</span><span class="p">))[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

      <span class="n">all_vcoords</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:]</span><span class="o">+</span><span class="n">all_vcoords</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
      <span class="n">all_vksis</span> <span class="o">=</span> <span class="n">find_ksi</span><span class="p">(</span><span class="n">ppts</span><span class="p">,</span> <span class="n">all_vcoords</span><span class="p">)</span>

      <span class="n">foundmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">all_vksis</span> <span class="o">&lt;=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">all_vksis</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

      <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">foundmask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">all_vksis</span> <span class="o">=</span> <span class="n">all_vksis</span><span class="p">[</span><span class="n">ind</span><span class="p">,:]</span>

      <span class="n">found_pts</span> <span class="o">=</span> <span class="n">pinds</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
      <span class="n">found_pts</span><span class="p">,</span> <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">found_pts</span><span class="p">,</span> <span class="n">return_index</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>



      <span class="n">ksis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
      <span class="n">duals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;i,i,i&quot;</span><span class="p">)</span>
      <span class="n">duals</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">dduals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_verts</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;i,i,i&quot;</span><span class="p">)[</span><span class="n">ind</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;i,i,i&quot;</span><span class="p">)</span>

      <span class="n">ksis</span><span class="p">[</span><span class="n">found_pts</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">all_vksis</span><span class="p">[</span><span class="n">inds</span><span class="p">,:]</span>
      <span class="n">duals</span><span class="p">[</span><span class="n">found_pts</span><span class="p">]</span> <span class="o">=</span> <span class="n">dduals</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>

      <span class="k">return</span> <span class="n">duals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">),</span> <span class="n">ksis</span></div>

      
   <span class="c1"># For now, combined caching accessor and builder</span>
<div class="viewcode-block" id="VlsvReader.build_cell_vertices">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.build_cell_vertices">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">build_cell_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cid</span><span class="p">,</span> <span class="n">prune_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Builds, caches and returns the vertices that lie on the surfaces of CellIDs cid.</span>
<span class="sd">      </span>
<span class="sd">      :parameter cid: numpy array of CellIDs</span>
<span class="sd">      :parameter prune_unique: bool [False], if you suspect you might be calling the function many times with the </span>
<span class="sd">                               same CellID in the list, it might be beneficial to enable this and not repeat the operation for duplicate entries.</span>

<span class="sd">      :returns: Dictionary of cell c (int) : set of vertex indices (3-tuple) that touch the cell c.</span>

<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">if</span> <span class="n">prune_unique</span><span class="p">:</span>
         <span class="n">cid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>

      <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">dict_keys_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cell_vertices</span><span class="p">,</span><span class="n">cid</span><span class="p">,</span><span class="n">prune_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
      <span class="c1"># {cid : 8-tuple of vertex_inds}</span>
      
      <span class="n">cell_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_cell_neighborhoods</span><span class="p">(</span><span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
      <span class="n">corner_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_corner_vertices</span><span class="p">(</span><span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>

      <span class="n">levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_amr_level</span><span class="p">(</span><span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>

      <span class="c1"># find irregular cells</span>
      <span class="c1"># irregular_mask = np.array([np.any(levels[i] != self.get_amr_level(np.array(list(cell_neighbors[c])))) for i,c in enumerate(cid[mask])],dtype=bool)</span>
      <span class="n">mask</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="c1">#&amp; irregular_mask # beautiful</span>
      
      <span class="n">cell_hanging_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">]}</span>

      <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_corner_vertices</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">])(</span><span class="n">cell_neighbors</span><span class="p">)))))</span>
      <span class="k">elif</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">):</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_corner_vertices</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">])(</span><span class="n">cell_neighbors</span><span class="p">)))))</span>
      <span class="c1"># Loop over all the irregular cells (with finer neighbours) that may have hanging nodes</span>
      <span class="c1"># for i,c in enumerate(irregular_cells):</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">]):</span>
         <span class="n">corners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cell_corner_vertices</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
         <span class="c1"># finer_neighbors = [n for n in cell_neighbors[c] if self.get_amr_level(n) &gt; levels[i]]</span>
         <span class="n">hanging_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
         <span class="c1"># ncorners = self.get_cell_corner_vertices(np.array(finer_neighbors))</span>
         <span class="n">ncorners</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="n">cell_neighbors</span><span class="p">[</span><span class="n">c</span><span class="p">])(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cell_corner_vertices</span><span class="p">)</span> <span class="c1">#self.get_cell_corner_vertices(np.array(list(cell_neighbors[c])))</span>

         <span class="c1"># Possible hanging nodes are those that are the vertices of finer neighbours.</span>
         <span class="k">for</span> <span class="n">vertex_inds_set</span> <span class="ow">in</span> <span class="n">ncorners</span><span class="p">:</span><span class="c1">#.values():</span>
            <span class="n">hanging_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">vertex_inds_set</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">corner_vertices</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span> <span class="c1"># no need to add current corners</span>
         
         <span class="n">cmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">corners</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
         <span class="n">cmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">corners</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

         <span class="n">pruned_hangers</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hanging_set</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">cmax</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">cmin</span><span class="p">)}</span>
         <span class="n">cell_hanging_nodes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pruned_hangers</span><span class="p">)</span>

      <span class="n">vertices</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">corner_vertices</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">+</span><span class="n">cell_hanging_nodes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">]}</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__cell_vertices</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
      
      <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cid</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]:</span>
         <span class="n">vertices</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cell_vertices</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
      
      <span class="k">return</span> <span class="n">vertices</span></div>


<div class="viewcode-block" id="VlsvReader.get_cell_corner_vertices">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_cell_corner_vertices">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_cell_corner_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cids</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Builds, caches and returns the vertices that lie on the corners of CellIDs cid.</span>
<span class="sd">      :parameter cid: numpy array of CellIDs</span>

<span class="sd">      :returns: Dictionary of cell c (int) : 8-tuple of vertex indices (3-tuples).</span>

<span class="sd">      &#39;&#39;&#39;</span>

      <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">dict_keys_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cell_vertices</span><span class="p">,</span><span class="n">cids</span><span class="p">,</span><span class="n">prune_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
      <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_coordinates</span><span class="p">(</span><span class="n">cids</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
      <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">cids</span><span class="p">[</span><span class="n">mask</span><span class="p">]),</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
      <span class="n">cell_vertex_sets</span> <span class="o">=</span> <span class="p">{}</span>

      <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cids</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span> 
         <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
               <span class="k">for</span> <span class="n">z</span>  <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                  <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                     <span class="k">continue</span>
                  <span class="n">vertices</span><span class="p">[:,</span><span class="n">ii</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_indices</span><span class="p">(</span><span class="n">coords</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell_dx</span><span class="p">(</span><span class="n">cids</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
                  <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>

         <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cids</span><span class="p">[</span><span class="n">mask</span><span class="p">]):</span>
            <span class="n">vlist</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span>
            <span class="n">vtuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">])</span>
            <span class="n">cell_vertex_sets</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">vtuple</span>
            
         <span class="bp">self</span><span class="o">.</span><span class="n">__cell_corner_vertices</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell_vertex_sets</span><span class="p">)</span>

      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cids</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]):</span>
         <span class="n">cell_vertex_sets</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cell_corner_vertices</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

      <span class="k">return</span> <span class="n">cell_vertex_sets</span></div>



   <span class="c1"># again, combined getter and builder..</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">build_cell_neighborhoods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cids</span><span class="p">):</span>

      <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">dict_keys_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cell_neighbours</span><span class="p">,</span> <span class="n">cids</span><span class="p">,</span> <span class="n">prune_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
      <span class="n">cell_vertex_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_corner_vertices</span><span class="p">(</span><span class="n">cids</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span> <span class="c1"># these are enough to fetch the neighbours</span>

      <span class="n">cell_neighbor_sets</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cell_vertex_sets</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
      <span class="n">vertices_todo</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">cell_vertex_sets</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
      <span class="n">neighbor_tuples_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_dual_from_vertices</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">vertices_todo</span><span class="p">))</span>
      <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">verts</span> <span class="ow">in</span> <span class="n">cell_vertex_sets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
         <span class="c1"># neighbor_tuples = self.build_dual_from_vertices(verts)</span>
         <span class="c1"># cell_neighbor_sets[c].update(set().union(*neighbor_tuples.values()))</span>
         <span class="n">cell_neighbor_sets</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="n">cell_vertex_sets</span><span class="p">[</span><span class="n">c</span><span class="p">])(</span><span class="n">neighbor_tuples_dict</span><span class="p">)))</span>
      
      <span class="bp">self</span><span class="o">.</span><span class="n">__cell_neighbours</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cell_neighbor_sets</span><span class="p">)</span>

      <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cids</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]:</span>
         <span class="n">cell_neighbor_sets</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cell_neighbors</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

      <span class="k">return</span> <span class="n">cell_neighbor_sets</span>



   <span class="k">def</span><span class="w"> </span><span class="nf">build_dual_from_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>

      <span class="n">vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>

      <span class="c1"># I don&#39;t like this, but alternatives seem worse.</span>
      <span class="n">done</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">todo</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="c1"># mask = dict_keys_exist(self.__dual_cells, vertices)</span>
      <span class="c1"># mask = np.array([v not in self.__dual_cells.keys() for v in vertices],dtype=bool)</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
         <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dual_cells</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">done</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">todo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
      <span class="c1"># vertices=np.array(vertices,dtype=&quot;i,i,i&quot;)</span>
      <span class="c1"># done = [tuple(v) for v in vertices[mask]]</span>
      <span class="c1"># todo = [tuple(v) for v in vertices[~mask]]</span>

      <span class="n">dual_sets_done</span>   <span class="o">=</span> <span class="p">{</span><span class="n">v</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dual_cells</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">done</span><span class="p">}</span>
      
      <span class="n">dual_sets</span> <span class="o">=</span> <span class="p">{}</span>

      <span class="n">len_todo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">len_todo</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span><span class="c1">#np.sum(mask) &gt; 0:</span>
         
         <span class="n">dual_bboxes</span> <span class="o">=</span> <span class="p">{}</span>
         <span class="n">eps</span> <span class="o">=</span> <span class="mi">1</span>
         <span class="n">v_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">len_todo</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
         <span class="n">v_cellcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">len_todo</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
         <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="n">vcoords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_coordinates_from_indices</span><span class="p">(</span><span class="n">todo</span><span class="p">)</span>

         <span class="c1"># TODO get rid of the loop</span>
         <span class="n">offsets</span> <span class="o">=</span> <span class="p">[]</span>
         <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
               <span class="k">for</span> <span class="n">z</span>  <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                  <span class="n">offsets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span>
                  <span class="n">v_cellcoords</span><span class="p">[:,</span><span class="n">ii</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">eps</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">vcoords</span>
                  <span class="n">v_cells</span><span class="p">[:,</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cellid</span><span class="p">(</span><span class="n">v_cellcoords</span><span class="p">[:,</span><span class="n">ii</span><span class="p">])</span>
                  <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>

         <span class="n">v_cellcoords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_coordinates</span><span class="p">(</span><span class="n">v_cells</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

         <span class="n">dual_sets</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">vinds</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v_cells</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">vinds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">todo</span><span class="p">)})</span>
         <span class="n">mins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">v_cellcoords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
         <span class="n">maxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">v_cellcoords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
         <span class="n">dual_bboxes</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">vinds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">mins</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span><span class="n">maxs</span><span class="p">[</span><span class="n">i</span><span class="p">,:]))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">vinds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">todo</span><span class="p">)})</span>

         <span class="bp">self</span><span class="o">.</span><span class="n">__dual_cells</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dual_sets</span><span class="p">)</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__dual_bboxes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dual_bboxes</span><span class="p">)</span>
      <span class="n">dual_sets_done</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dual_sets</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">dual_sets_done</span>

   <span class="c1"># build a dual coverage to enable interpolation to each coordinate</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">build_duals_from_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
      
      <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
      <span class="n">cid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_cellids</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
      <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_coordinates</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>
      
      <span class="n">ncoords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">if</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Coordinates are required to be three-dimensional (coords.shape[1]==3 or convertible to such))&quot;</span><span class="p">)</span>
      
      <span class="n">vertices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
      <span class="n">vsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_cell_vertices</span><span class="p">(</span><span class="n">cid</span><span class="p">,</span><span class="n">prune_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
      <span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">vsets</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
      
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_dual_from_vertices</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>

   <span class="c1"># build a dual coverage to enable interpolation to each coordinate</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">build_duals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cid</span><span class="p">):</span>
      
      <span class="n">cid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>

      <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">dict_keys_exist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cell_duals</span><span class="p">,</span> <span class="n">cid</span><span class="p">,</span> <span class="n">prune_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

      <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
         <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_coordinates</span><span class="p">(</span><span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
         
         <span class="n">ncoords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
         <span class="k">if</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Coordinates are required to be three-dimensional (coords.shape[1]==3 or convertible to such))&quot;</span><span class="p">)</span>
         
         <span class="n">vertices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
         <span class="n">vsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_cell_vertices</span><span class="p">(</span><span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
         <span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">vsets</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
         <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cid</span><span class="p">[</span><span class="n">mask</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cell_duals</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">vsets</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
         
         <span class="bp">self</span><span class="o">.</span><span class="n">build_dual_from_vertices</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>



<div class="viewcode-block" id="VlsvReader.get_cell_coordinates">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_cell_coordinates">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_cell_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellids</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns a given cell&#39;s coordinates as a numpy array</span>

<span class="sd">      :param cellids:            The array of cell IDs</span>
<span class="sd">      :returns: a numpy array with the coordinates</span>

<span class="sd">      .. seealso:: :func:`get_cellid`</span>

<span class="sd">      .. note:: The cell ids go from 1 .. max not from 0</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="n">stack</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cellids</span><span class="p">,</span><span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
         <span class="n">cellids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span>
         <span class="n">stack</span> <span class="o">=</span> <span class="kc">False</span>

      <span class="c1"># Get cell lengths:</span>
      <span class="n">xcells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_refinement_level</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
      <span class="n">ycells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_refinement_level</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
      <span class="n">zcells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_refinement_level</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_refinement_level</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
         <span class="n">xcells</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
         <span class="n">ycells</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
         <span class="n">zcells</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__zcells</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

      <span class="n">reflevels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_amr_level</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span>
      <span class="n">cellindices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_indices</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span>

      <span class="c1"># Get cell coordinates:</span>
      <span class="n">cell_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">__xmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">xcells</span><span class="p">[</span><span class="n">reflevels</span><span class="p">]),</span>
                               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ymax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ymin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ycells</span><span class="p">[</span><span class="n">reflevels</span><span class="p">]),</span>
                               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__zmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__zmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">zcells</span><span class="p">[</span><span class="n">reflevels</span><span class="p">])])</span><span class="o">.</span><span class="n">T</span>
      <span class="n">mins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__xmin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">__ymin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">__zmin</span><span class="p">])</span>
      <span class="n">cellcoordinates</span> <span class="o">=</span> <span class="n">mins</span> <span class="o">+</span> <span class="p">(</span><span class="n">cellindices</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">cell_lengths</span>
      <span class="c1"># Return the coordinates:</span>
      <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cellcoordinates</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cellcoordinates</span><span class="p">)[</span><span class="mi">0</span><span class="p">,:]</span></div>


<div class="viewcode-block" id="VlsvReader.get_cell_indices">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_cell_indices">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_cell_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellids</span><span class="p">,</span> <span class="n">reflevels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns a given cell&#39;s indices as a numpy array</span>

<span class="sd">      :param cellid:            The cell&#39;s ID, numpy array</span>
<span class="sd">      :param reflevel:          The cell&#39;s refinement level in the AMR</span>
<span class="sd">      :returns: a numpy array with the coordinates</span>

<span class="sd">      .. seealso:: :func:`get_cellid`</span>

<span class="sd">      .. note:: The cell ids go from 1 .. max not from 0</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="n">stack</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cellids</span><span class="p">,</span><span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
         <span class="n">cellids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span>
         <span class="n">stack</span> <span class="o">=</span> <span class="kc">False</span>

      <span class="k">if</span> <span class="n">reflevels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="n">reflevels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_amr_level</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">reflevels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">reflevels</span><span class="p">)</span>

      <span class="n">mask</span> <span class="o">=</span> <span class="n">reflevels</span> <span class="o">&gt;=</span> <span class="mi">0</span>
      <span class="c1"># Calculating the index of the first cell at this reflevel</span>
      <span class="n">index_at_reflevel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_refinement_level</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
      <span class="n">isum</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_refinement_level</span><span class="p">()):</span>
         <span class="n">isum</span> <span class="o">=</span> <span class="n">isum</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__zcells</span>
         <span class="n">index_at_reflevel</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">isum</span>


      <span class="c1"># Get cell indices:</span>
      <span class="n">cellids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cellids</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">index_at_reflevel</span><span class="p">[</span><span class="n">reflevels</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
      <span class="n">cellindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">cellids</span><span class="p">),</span><span class="mi">3</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cellids</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">%</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">reflevels</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span><span class="p">)</span>
      <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">cellids</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">//</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">reflevels</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span><span class="p">))</span><span class="o">%</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">reflevels</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span><span class="p">)</span>
      <span class="n">cellindices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cellids</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">//</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">reflevels</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span><span class="p">)</span>

      <span class="c1"># Return the indices:</span>
      <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cellindices</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cellindices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="VlsvReader.get_cell_neighbor">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_cell_neighbor">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_cell_neighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellidss</span><span class="p">,</span> <span class="n">offsetss</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">prune_uniques</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns a given cells neighbor at offset (in indices)</span>

<span class="sd">      :param cellids:            The cell&#39;s ID</span>
<span class="sd">      :param offsets:            The offset to the neighbor in indices</span>
<span class="sd">      :param periodic:          For each dimension, is the system periodic</span>
<span class="sd">      :returns: the cellid of the neighbor</span>

<span class="sd">      .. note:: Returns 0 if the offset is out of bounds!</span>

<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">stack</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cellidss</span><span class="p">,</span><span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
         <span class="n">cellidss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">cellidss</span><span class="p">)</span>
         <span class="n">offsetss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">offsetss</span><span class="p">)</span>
         <span class="n">stack</span> <span class="o">=</span> <span class="kc">False</span>

      <span class="k">if</span> <span class="n">prune_uniques</span><span class="p">:</span>
         <span class="n">fullargs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cellidss</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span><span class="n">offsetss</span><span class="p">)))</span>
         <span class="n">uniqueargs</span><span class="p">,</span> <span class="n">inverse_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">fullargs</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
         <span class="n">cellids</span> <span class="o">=</span> <span class="n">uniqueargs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
         <span class="n">offsets</span> <span class="o">=</span> <span class="n">uniqueargs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">cellids</span> <span class="o">=</span> <span class="n">cellidss</span>
         <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsetss</span>
         <span class="n">inverse_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">cellids</span><span class="p">),))</span>


      <span class="n">reflevel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_amr_level</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span>
      <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cell_indices</span><span class="p">(</span><span class="n">cellids</span><span class="p">,</span> <span class="n">reflevel</span><span class="p">)</span>

      <span class="n">cellid_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cellids</span><span class="p">)</span>
      <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cellids</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
      <span class="c1"># Special case if no offset (return self in that case); and require in-domain reflevel</span>
      <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">offsets</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">offsets</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">offsets</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">reflevel</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

      <span class="c1"># Getting the neighbour at the same refinement level</span>
      <span class="n">ngbr_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">cellids</span><span class="p">),</span><span class="mi">3</span><span class="p">))</span>
      <span class="n">sys_sizes</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ngbr_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
      <span class="n">sys_sizes</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">reflevel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span>
      <span class="n">sys_sizes</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">reflevel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span>
      <span class="n">sys_sizes</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">reflevel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__zcells</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
         <span class="n">ngbr_indices</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
         <span class="k">if</span> <span class="n">periodic</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">lowmask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ngbr_indices</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ngbr_indices</span><span class="p">[</span><span class="n">lowmask</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ngbr_indices</span><span class="p">[</span><span class="n">lowmask</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">sys_sizes</span><span class="p">[</span><span class="n">lowmask</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
            <span class="n">himask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ngbr_indices</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sys_sizes</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ngbr_indices</span><span class="p">[</span><span class="n">himask</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ngbr_indices</span><span class="p">[</span><span class="n">himask</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">sys_sizes</span><span class="p">[</span><span class="n">himask</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
   
         <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">ngbr_indices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ngbr_indices</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sys_sizes</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="n">i</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error in Vlsvreader get_cell_neighbor: neighbor out of bounds&quot;</span><span class="p">)</span>

      <span class="n">coord_neighbor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngbr_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
      <span class="n">coord_neighbor</span><span class="p">[</span><span class="n">mask</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__xmin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">__ymin</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">__zmin</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">ngbr_indices</span><span class="p">[</span><span class="n">mask</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__dx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">__dy</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">__dz</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">reflevel</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
      
      <span class="n">cellid_neighbors</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cellid</span><span class="p">(</span><span class="n">coord_neighbor</span><span class="p">[</span><span class="n">mask</span><span class="p">,:])</span>
      <span class="n">cellid_neighbors</span><span class="p">[(</span><span class="n">offsets</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">offsets</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">offsets</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cellids</span><span class="p">[(</span><span class="n">offsets</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">offsets</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">offsets</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)]</span>

      <span class="c1"># if np.any(self.get_amr_level(cellid_neighbors)!=reflevel):</span>
      <span class="c1">#    warnings.warn(&quot;A neighboring cell found at a different refinement level. Behaviour is janky, and results will vary.&quot;)</span>

      <span class="c1"># Return the neighbor cellids/cellid:</span>
      <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cellid_neighbors</span><span class="p">[</span><span class="n">inverse_indices</span><span class="p">])</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cellid_neighbors</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


   <span class="k">def</span><span class="w"> </span><span class="nf">get_WID</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="c1"># default WID=4</span>
      <span class="n">widval</span><span class="o">=</span><span class="mi">4</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_parameter</span><span class="p">(</span><span class="s2">&quot;velocity_block_width&quot;</span><span class="p">):</span>
         <span class="n">widval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_parameter</span><span class="p">(</span><span class="s2">&quot;velocity_block_width&quot;</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">widval</span>

<div class="viewcode-block" id="VlsvReader.get_velocity_cell_indices">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_velocity_cell_indices">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_velocity_cell_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vcellcoord</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns velocity cell indices for a dense array format</span>
<span class="sd">      NB: This view does not consider blocks at all.</span>

<span class="sd">      :param vcellcoord:   Coordinates of the velocity cell(s)</span>
<span class="sd">      :param pop:          Population [&quot;proton&quot;]</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="c1"># WID=self.get_WID()</span>
      <span class="c1"># WID2=WID*WID</span>
      <span class="c1"># WID3=WID2*WID</span>
      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>

      <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxmin</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vymin</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vzmin</span><span class="p">])</span>
      <span class="c1"># print(vmin)</span>
      <span class="n">dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__dvx</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvy</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvz</span><span class="p">])</span>
      <span class="c1"># print(dv)</span>
      <span class="n">cell_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">vcellcoord</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">dv</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">cell_index</span></div>


<div class="viewcode-block" id="VlsvReader.get_velocity_cell_ids">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_velocity_cell_ids">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_velocity_cell_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vcellcoord</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns velocity cell ids of given coordinate</span>

<span class="sd">      Arguments:</span>
<span class="sd">      :param vcellcoords: One 3d coordinate</span>
<span class="sd">      :returns: Velocity cell id</span>

<span class="sd">      .. seealso:: :func:`get_velocity_cell_coordinates`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">WID</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_WID</span><span class="p">()</span>
      <span class="n">WID2</span><span class="o">=</span><span class="n">WID</span><span class="o">*</span><span class="n">WID</span>
      <span class="n">WID3</span><span class="o">=</span><span class="n">WID2</span><span class="o">*</span><span class="n">WID</span>
      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>

      <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxmin</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vymin</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vzmin</span><span class="p">])</span>
      <span class="n">dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__dvx</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvy</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvz</span><span class="p">])</span>
      <span class="n">block_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">vcellcoord</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">WID</span> <span class="o">*</span> <span class="n">dv</span><span class="p">))</span>
      <span class="n">cell_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">vcellcoord</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">WID</span> <span class="o">*</span> <span class="n">dv</span><span class="p">)</span> <span class="o">/</span> <span class="n">dv</span><span class="p">)</span>
      <span class="n">vcellid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block_index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="n">vcellid</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">)</span>
      <span class="n">vcellid</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block_index</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">)</span>
      <span class="n">vcellid</span> <span class="o">*=</span> <span class="n">WID3</span>
      <span class="n">vcellid</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell_index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="n">vcellid</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">WID</span><span class="p">)</span>
      <span class="n">vcellid</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell_index</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">WID2</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">vcellid</span></div>


<div class="viewcode-block" id="VlsvReader.get_velocity_cell_coordinates">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_velocity_cell_coordinates">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_velocity_cell_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vcellids</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns a given velocity cell&#39;s coordinates as a numpy array</span>

<span class="sd">      Arguments:</span>
<span class="sd">      :param vcellids:       The velocity cell&#39;s ID</span>
<span class="sd">      :returns: a numpy array with the coordinates</span>

<span class="sd">      .. seealso:: :func:`get_cell_coordinates` :func:`get_velocity_block_coordinates`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">vcellids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">vcellids</span><span class="p">)</span>
      <span class="n">WID</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_WID</span><span class="p">()</span>
      <span class="n">WID2</span><span class="o">=</span><span class="n">WID</span><span class="o">*</span><span class="n">WID</span>
      <span class="n">WID3</span><span class="o">=</span><span class="n">WID2</span><span class="o">*</span><span class="n">WID</span>
      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="c1"># Get block ids:</span>
      <span class="n">blocks</span> <span class="o">=</span> <span class="n">vcellids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">//</span> <span class="n">WID3</span>
      <span class="c1"># Get block coordinates:</span>
      <span class="n">blockIndicesX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">))</span>
      <span class="n">blockIndicesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">))</span>
      <span class="n">blockIndicesZ</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">)</span>
      <span class="n">blockCoordinatesX</span> <span class="o">=</span> <span class="n">blockIndicesX</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvx</span> <span class="o">*</span> <span class="n">WID</span> <span class="o">+</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vxmin</span>
      <span class="n">blockCoordinatesY</span> <span class="o">=</span> <span class="n">blockIndicesY</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvy</span> <span class="o">*</span> <span class="n">WID</span> <span class="o">+</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vymin</span>
      <span class="n">blockCoordinatesZ</span> <span class="o">=</span> <span class="n">blockIndicesZ</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvz</span> <span class="o">*</span> <span class="n">WID</span> <span class="o">+</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vzmin</span>
      <span class="c1"># Get cell indices:</span>
      <span class="n">cellids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">vcellids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">WID3</span><span class="p">))</span>
      <span class="n">cellIndicesX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">cellids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">WID</span><span class="p">))</span>
      <span class="n">cellIndicesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">((</span><span class="n">cellids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">WID</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">WID</span><span class="p">))</span>
      <span class="n">cellIndicesZ</span> <span class="o">=</span> <span class="n">cellids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">WID2</span><span class="p">)</span>
      <span class="c1"># Get cell coordinates:</span>
      <span class="n">cellCoordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">blockCoordinatesX</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cellIndicesX</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvx</span><span class="p">,</span>
                                  <span class="n">blockCoordinatesY</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cellIndicesY</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvy</span><span class="p">,</span>
                                  <span class="n">blockCoordinatesZ</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cellIndicesZ</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvz</span><span class="p">])</span>

      <span class="k">return</span> <span class="n">cellCoordinates</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>


<div class="viewcode-block" id="VlsvReader.get_velocity_block_indices">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_velocity_block_indices">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_velocity_block_indices</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blocks</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns the block indices of the given blocks in a numpy array</span>

<span class="sd">          :param blocks:         list of block ids</span>
<span class="sd">          :returns: a numpy array containing the block indices e.g. np.array([np.array([2,1,3]), np.array([5,6,6]), ..])</span>

<span class="sd">          .. seealso:: :func:`get_velocity_block_coordinates`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">WID</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_WID</span><span class="p">()</span>
      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="n">blockIndicesX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">))</span>
      <span class="n">blockIndicesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">))</span>
      <span class="n">blockIndicesZ</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">)</span>
      <span class="c1"># Return the indices:</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">blockIndicesX</span><span class="p">,</span>
                       <span class="n">blockIndicesY</span><span class="p">,</span>
                       <span class="n">blockIndicesZ</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>


   <span class="k">def</span><span class="w"> </span><span class="nf">get_velocity_blockGID</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blockindices</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
      <span class="n">WID</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_WID</span><span class="p">()</span>
      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="n">bIX</span> <span class="o">=</span> <span class="n">blockindices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">bIY</span> <span class="o">=</span> <span class="n">blockindices</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
      <span class="n">bIZ</span> <span class="o">=</span> <span class="n">blockindices</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>

      <span class="n">GIDs</span> <span class="o">=</span> <span class="n">bIZ</span> <span class="o">+</span> <span class="n">bIY</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vzblocks</span> <span class="o">+</span> <span class="n">bIX</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vzblocks</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span>
      <span class="k">return</span> <span class="n">GIDs</span>

<div class="viewcode-block" id="VlsvReader.get_velocity_block_coordinates">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_velocity_block_coordinates">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_velocity_block_coordinates</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blocks</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns the block coordinates of the given blocks in a numpy array</span>

<span class="sd">          :param blocks:         list of block ids</span>
<span class="sd">          :returns: a numpy array containing the block coordinates e.g. np.array([np.array([2,1,3]), np.array([5,6,6]), ..])</span>

<span class="sd">          .. seealso:: :func:`get_velocity_cell_coordinates`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">WID</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_WID</span><span class="p">()</span>
      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="n">blockIndicesX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">))</span>
      <span class="n">blockIndicesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">))</span>
      <span class="n">blockIndicesZ</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">)</span>
      <span class="n">blockCoordinatesX</span> <span class="o">=</span> <span class="n">blockIndicesX</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvx</span> <span class="o">*</span> <span class="n">WID</span> <span class="o">+</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vxmin</span>
      <span class="n">blockCoordinatesY</span> <span class="o">=</span> <span class="n">blockIndicesY</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvy</span> <span class="o">*</span> <span class="n">WID</span> <span class="o">+</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vymin</span>
      <span class="n">blockCoordinatesZ</span> <span class="o">=</span> <span class="n">blockIndicesZ</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvz</span> <span class="o">*</span> <span class="n">WID</span> <span class="o">+</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vzmin</span>
      <span class="c1"># Return the coordinates:</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">blockCoordinatesX</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
                       <span class="n">blockCoordinatesY</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
                       <span class="n">blockCoordinatesZ</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>


<div class="viewcode-block" id="VlsvReader.get_velocity_blocks">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_velocity_blocks">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_velocity_blocks</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blockCoordinates</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span> <span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns the block ids of the given block coordinates in a numpy array form</span>

<span class="sd">          :param blockcoordinates:         list of block coordinates e.g. np.array([np.array([2,1,3]), np.array([5,6,6]), ..])</span>
<span class="sd">          :returns: a numpy array containing the block ids e.g. np.array([4,2,56,44,2, ..])</span>

<span class="sd">          .. seealso:: :func:`get_velocity_block_coordinates`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">WID</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_WID</span><span class="p">()</span>
      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="n">mins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxmin</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vymin</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vzmin</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
      <span class="n">dvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">WID</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__dvx</span><span class="p">,</span> <span class="n">WID</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__dvy</span><span class="p">,</span> <span class="n">WID</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__dvz</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
      <span class="n">multiplier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
      <span class="n">velocity_block_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(((</span><span class="n">blockCoordinates</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">-</span> <span class="n">mins</span><span class="p">)</span> <span class="o">/</span> <span class="n">dvs</span><span class="p">))</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">velocity_block_ids</span></div>


<div class="viewcode-block" id="VlsvReader.construct_velocity_cells">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.construct_velocity_cells">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">construct_velocity_cells</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blocks</span> <span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns velocity cells in given blocks</span>

<span class="sd">          :param blocks:         list of block ids</span>
<span class="sd">          :returns: a numpy array containing the velocity cell ids e.g. np.array([4,2,56,44,522, ..])</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">WID</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_WID</span><span class="p">()</span>
      <span class="n">WID3</span><span class="o">=</span><span class="n">WID</span><span class="o">*</span><span class="n">WID</span><span class="o">*</span><span class="n">WID</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">blocks</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">WID3</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">WID3</span><span class="p">))</span></div>


<div class="viewcode-block" id="VlsvReader.construct_velocity_cell_coordinates">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.construct_velocity_cell_coordinates">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">construct_velocity_cell_coordinates</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blocks</span> <span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns velocity cell coordinates in given blocks</span>

<span class="sd">          :param blocks:         list of block ids</span>
<span class="sd">          :returns: a numpy array containing the velocity cell ids e.g. np.array([4,2,56,44,522, ..])</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="c1"># Construct velocity cell coordinates from velocity cells and return them</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_velocity_cell_coordinates</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_velocity_cells</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="p">)</span></div>



<div class="viewcode-block" id="VlsvReader.construct_velocity_cell_nodes">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.construct_velocity_cell_nodes">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">construct_velocity_cell_nodes</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blocks</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span> <span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Returns velocity cell nodes in given blocks</span>

<span class="sd">          :param blocks:         list of block ids</span>
<span class="sd">          :returns: a numpy array containing velocity cell nodes and the keys for velocity cells</span>

<span class="sd">          .. note:: This is used for constructing velocity space inside the mayavi module</span>

<span class="sd">          .. seealso:: :mod:`grid`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
      <span class="n">WID</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_WID</span><span class="p">()</span>
      <span class="n">WID2</span><span class="o">=</span><span class="n">WID</span><span class="o">*</span><span class="n">WID</span>
      <span class="n">WID3</span><span class="o">=</span><span class="n">WID2</span><span class="o">*</span><span class="n">WID</span>
      <span class="c1"># Get block coordinates:</span>
      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="n">blockIndicesX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
      <span class="n">blockIndicesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
      <span class="n">blockIndicesZ</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>

      <span class="n">cellsPerDirection</span> <span class="o">=</span> <span class="n">WID</span>
      <span class="n">cellsPerBlock</span> <span class="o">=</span> <span class="n">WID3</span>

      <span class="c1"># Get velocity cell min coordinates (per velocity block)</span>
      <span class="n">vcellids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cellsPerBlock</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
      <span class="n">cellIndicesX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">vcellids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">cellsPerDirection</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
      <span class="n">cellIndicesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">((</span><span class="n">vcellids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">cellsPerDirection</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">cellsPerDirection</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
      <span class="n">cellIndicesZ</span> <span class="o">=</span> <span class="p">(</span><span class="n">vcellids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">cellsPerDirection</span><span class="o">*</span><span class="n">cellsPerDirection</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>

      <span class="c1"># Construct velocity cell node indices for every velocity cell per velocity block</span>

      <span class="n">nodesPerCell</span> <span class="o">=</span> <span class="mi">8</span>

      <span class="c1"># NOTE: The ordering of the numpy array won&#39;t make sense to anyone who hasn&#39;t read VTK documentation. For further info check VTK_VOXEL. The numpy array is constructed according to VTK voxel&#39;s nodes</span>
      <span class="n">cellNodeIndicesX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">cellIndicesX</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nodesPerCell</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
      <span class="n">cellNodeIndicesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">cellIndicesY</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nodesPerCell</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
      <span class="n">cellNodeIndicesZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">cellIndicesZ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nodesPerCell</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>

      <span class="n">nodeIndices_local</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">nodesPerDirection</span> <span class="o">=</span> <span class="mi">5</span>

      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nodesPerDirection</span><span class="p">):</span>
         <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nodesPerDirection</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nodesPerDirection</span><span class="p">):</span>
               <span class="n">nodeIndices_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]))</span>
      <span class="n">nodeIndices_local</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodeIndices_local</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>

      <span class="n">nodesPerBlock</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">nodesPerDirection</span> <span class="o">*</span> <span class="n">nodesPerDirection</span> <span class="o">*</span> <span class="n">nodesPerDirection</span><span class="p">)</span>


      <span class="k">def</span><span class="w"> </span><span class="nf">calculate_node_indices</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blockIndicesX</span><span class="p">,</span> <span class="n">blockIndicesY</span><span class="p">,</span> <span class="n">blockIndicesZ</span><span class="p">,</span> <span class="n">nodeIndices_local</span><span class="p">,</span> <span class="n">nodesPerBlock</span><span class="p">,</span> <span class="n">cellsPerDirection</span> <span class="p">):</span>
         <span class="n">nodeIndicesX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">blockIndicesX</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nodesPerBlock</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">))</span> <span class="o">*</span> <span class="n">cellsPerDirection</span> <span class="o">+</span> <span class="n">nodeIndices_local</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
         <span class="n">nodeIndicesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">blockIndicesY</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nodesPerBlock</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">))</span> <span class="o">*</span> <span class="n">cellsPerDirection</span> <span class="o">+</span> <span class="n">nodeIndices_local</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
         <span class="n">nodeIndicesZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">blockIndicesZ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nodesPerBlock</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">))</span> <span class="o">*</span> <span class="n">cellsPerDirection</span> <span class="o">+</span> <span class="n">nodeIndices_local</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
   
         <span class="n">nodeIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nodeIndicesX</span><span class="p">,</span> <span class="n">nodeIndicesY</span><span class="p">,</span> <span class="n">nodeIndicesZ</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

         <span class="c1"># Transform indices into unique keys</span>
         <span class="n">nodeKeys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nodeIndices</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">cellsPerDirection</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">cellsPerDirection</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">cellsPerDirection</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="o">+</span><span class="mi">1</span><span class="p">)]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
         <span class="c1"># Sort the keys and delete duplicates</span>
         <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nodeKeys</span><span class="p">)</span>
      <span class="c1">#nodeIndices = calculate_node_indices( blockIndicesX, blockIndicesY, blockIndicesZ, nodeIndices_local, nodesPerBlock, cellsPerDirection )</span>

      <span class="c1"># Put the node indices into keys:</span>
      <span class="n">nodeKeys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
      <span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
         <span class="n">fromIndex</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blockIndicesX</span><span class="p">)</span><span class="o">//</span><span class="n">N</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">toIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blockIndicesX</span><span class="p">)</span><span class="o">//</span><span class="n">N</span><span class="p">)</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">toIndex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blockIndicesX</span><span class="p">)</span>
         <span class="n">nodeKeys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodeKeys</span><span class="p">,</span> <span class="n">calculate_node_indices</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blockIndicesX</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">:</span><span class="n">toIndex</span><span class="p">],</span> <span class="n">blockIndicesY</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">:</span><span class="n">toIndex</span><span class="p">],</span> <span class="n">blockIndicesZ</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">:</span><span class="n">toIndex</span><span class="p">],</span> <span class="n">nodeIndices_local</span><span class="p">,</span> <span class="n">nodesPerBlock</span><span class="p">,</span> <span class="n">cellsPerDirection</span> <span class="p">)</span> <span class="p">)</span>


      <span class="c1"># Delete duplicate nodes and sort the list:</span>
      <span class="n">nodeKeys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nodeKeys</span><span class="p">)</span> <span class="c1">#We now have all of the nodes in a list!</span>




      <span class="k">def</span><span class="w"> </span><span class="nf">calc_global_cell_keys</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blockIndicesX</span><span class="p">,</span> <span class="n">blockIndicesY</span><span class="p">,</span> <span class="n">blockIndicesZ</span><span class="p">,</span> <span class="n">cellNodeIndicesX</span><span class="p">,</span> <span class="n">cellNodeIndicesY</span><span class="p">,</span> <span class="n">cellNodeIndicesZ</span><span class="p">,</span> <span class="n">cellsPerBlock</span><span class="p">,</span> <span class="n">nodesPerCell</span><span class="p">,</span> <span class="n">cellsPerDirection</span><span class="p">,</span> <span class="n">nodeKeys</span> <span class="p">):</span>
         <span class="c1"># reate node  indices for the cells</span>
         <span class="n">globalCellIndicesX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">blockIndicesX</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cellsPerBlock</span> <span class="o">*</span> <span class="n">nodesPerCell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">))</span> <span class="o">*</span> <span class="n">cellsPerDirection</span> <span class="o">+</span> <span class="n">cellNodeIndicesX</span><span class="p">)</span>
         <span class="n">globalCellIndicesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">blockIndicesY</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cellsPerBlock</span> <span class="o">*</span> <span class="n">nodesPerCell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">))</span> <span class="o">*</span> <span class="n">cellsPerDirection</span> <span class="o">+</span> <span class="n">cellNodeIndicesY</span><span class="p">)</span>
         <span class="n">globalCellIndicesZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">blockIndicesZ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cellsPerBlock</span> <span class="o">*</span> <span class="n">nodesPerCell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">))</span> <span class="o">*</span> <span class="n">cellsPerDirection</span> <span class="o">+</span> <span class="n">cellNodeIndicesZ</span><span class="p">)</span>
   
         <span class="n">globalCellIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">globalCellIndicesX</span><span class="p">,</span> <span class="n">globalCellIndicesY</span><span class="p">,</span> <span class="n">globalCellIndicesZ</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
         <span class="n">globalCellIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">globalCellIndices</span><span class="p">)</span>
         <span class="c1"># Transform cell indices into unique keys</span>
         <span class="n">globalCellIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">globalCellIndices</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">cellsPerDirection</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">cellsPerDirection</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">cellsPerDirection</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="o">+</span><span class="mi">1</span><span class="p">)]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
         <span class="c1"># Return cell nodes&#39; indexes in the nodeKeys list</span>
         <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">nodeKeys</span><span class="p">,</span> <span class="n">globalCellIndices</span><span class="p">)</span>


      <span class="c1"># Create cellKeys</span>
      <span class="n">cellKeys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blockIndicesX</span><span class="p">)</span><span class="o">*</span><span class="n">cellsPerBlock</span><span class="o">*</span><span class="n">nodesPerCell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
      <span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
      <span class="c1"># Append keys in cuts to save memory</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
         <span class="n">fromIndex</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blockIndicesX</span><span class="p">)</span><span class="o">//</span><span class="n">N</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">toIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blockIndicesX</span><span class="p">)</span><span class="o">//</span><span class="n">N</span><span class="p">)</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">toIndex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blockIndicesX</span><span class="p">)</span>
         <span class="c1"># Append cell keys</span>
         <span class="n">cellKeys</span><span class="p">[</span><span class="n">fromIndex</span><span class="o">*</span><span class="n">cellsPerBlock</span><span class="o">*</span><span class="n">nodesPerCell</span><span class="p">:</span><span class="n">toIndex</span><span class="o">*</span><span class="n">cellsPerBlock</span><span class="o">*</span><span class="n">nodesPerCell</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_global_cell_keys</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blockIndicesX</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">:</span><span class="n">toIndex</span><span class="p">],</span> <span class="n">blockIndicesY</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">:</span><span class="n">toIndex</span><span class="p">],</span> <span class="n">blockIndicesZ</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">:</span><span class="n">toIndex</span><span class="p">],</span> <span class="n">cellNodeIndicesX</span><span class="p">,</span> <span class="n">cellNodeIndicesY</span><span class="p">,</span> <span class="n">cellNodeIndicesZ</span><span class="p">,</span> <span class="n">cellsPerBlock</span><span class="p">,</span> <span class="n">nodesPerCell</span><span class="p">,</span> <span class="n">cellsPerDirection</span><span class="p">,</span> <span class="n">nodeKeys</span> <span class="p">)</span>

      <span class="n">cellKeys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">cellKeys</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span><span class="o">*</span><span class="mi">64</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

      <span class="c1"># We now have all the cell keys and avgs values! (avgs is in the same order as cell keys)</span>
      <span class="c1"># Now transform node indices back into real indices</span>
      <span class="n">nodeCoordinatesX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">nodeKeys</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">cellsPerDirection</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvx</span> <span class="o">+</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vxmin</span>
      <span class="n">nodeCoordinatesY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">nodeKeys</span><span class="o">//</span><span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">cellsPerDirection</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">cellsPerDirection</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvy</span> <span class="o">+</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vymin</span>
      <span class="n">nodeCoordinatesZ</span> <span class="o">=</span> <span class="p">(</span> <span class="n">nodeKeys</span> <span class="o">//</span> <span class="p">(</span><span class="nb">int</span><span class="p">)((</span><span class="n">cellsPerDirection</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cellsPerDirection</span><span class="o">*</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvz</span> <span class="o">+</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vzmin</span>
      
      <span class="c1"># Nodekeyss is no longer needed</span>
      <span class="k">del</span> <span class="n">nodeKeys</span>

      <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nodeCoordinatesX</span><span class="p">,</span> <span class="n">nodeCoordinatesY</span><span class="p">,</span> <span class="n">nodeCoordinatesZ</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
      <span class="c1"># Take a transpose</span>
      <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

      <span class="k">return</span> <span class="p">[</span><span class="n">nodes</span><span class="p">,</span> <span class="n">cellKeys</span><span class="p">]</span></div>






<div class="viewcode-block" id="VlsvReader.read_parameter">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_parameter">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read a parameter from the vlsv file</span>

<span class="sd">      :param name:   Name of the parameter</span>
<span class="sd">      :returns: The parameter value</span>

<span class="sd">      .. seealso:: :func:`read_variable` :func:`read_variable_info`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      
      <span class="c1"># Special handling for time</span>
      <span class="k">if</span> <span class="n">name</span><span class="o">==</span><span class="s2">&quot;time&quot;</span><span class="p">:</span>
         <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;t&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;PARAMETER&quot;</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">name</span><span class="o">==</span><span class="s2">&quot;t&quot;</span><span class="p">:</span>
         <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;PARAMETER&quot;</span><span class="p">)</span>

      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;PARAMETER&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="VlsvReader.read_velocity_distribution_dense">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_velocity_distribution_dense">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_velocity_distribution_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellid</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">,</span> <span class="n">regularize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">setThreshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">      Read the velocity space of a given cell and return a dense VDF as a numpy array (along with datacube edges)</span>
<span class="sd">      </span>
<span class="sd">      :param cellid:       Cell ID of the cell whose velocity distribution the function will read</span>
<span class="sd">      :kwarg pop:          Population to read [&quot;proton&quot;]</span>
<span class="sd">      :kwarg regularize:   replace negative values (fringing effects) with zeros [True]</span>

<span class="sd">      :returns: dense_array [np.ndarray], edges</span>
<span class="sd">      &#39;&#39;&#39;</span>

      <span class="n">velocity_cell_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_velocity_cells</span><span class="p">(</span><span class="n">cellid</span><span class="p">,</span> <span class="n">pop</span><span class="p">)</span>
      <span class="n">maps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">velocity_cell_map</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
      <span class="n">velocity_cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
      <span class="n">velocity_cell_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">setThreshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="c1"># Drop all velocity cells which are below the sparsity threshold. Otherwise the plot will show buffer</span>
         <span class="c1"># cells as well.</span>
         <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_variable</span><span class="p">(</span><span class="s1">&#39;MinValue&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># Sparsity threshold used to be saved as MinValue</span>
             <span class="n">setThreshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="s1">&#39;MinValue&#39;</span><span class="p">,</span><span class="n">cellid</span><span class="p">)</span>
             <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found a vlsv file MinValue of &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">setThreshold</span><span class="p">))</span>
         <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_variable</span><span class="p">(</span><span class="n">pop</span><span class="o">+</span><span class="s2">&quot;/EffectiveSparsityThreshold&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
             <span class="n">setThreshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">pop</span><span class="o">+</span><span class="s2">&quot;/EffectiveSparsityThreshold&quot;</span><span class="p">,</span><span class="n">cellid</span><span class="p">)</span>
             <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found a vlsv file value &quot;</span><span class="o">+</span><span class="n">pop</span><span class="o">+</span><span class="s2">&quot;/EffectiveSparsityThreshold&quot;</span><span class="o">+</span><span class="s2">&quot; of &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">setThreshold</span><span class="p">))</span>
         <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_variable</span><span class="p">(</span><span class="n">pop</span><span class="o">+</span><span class="s2">&quot;/vg_effectivesparsitythreshold&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
             <span class="n">setThreshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">pop</span><span class="o">+</span><span class="s2">&quot;/vg_effectivesparsitythreshold&quot;</span><span class="p">,</span><span class="n">cellid</span><span class="p">)</span>
             <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found a vlsv file value &quot;</span><span class="o">+</span><span class="n">pop</span><span class="o">+</span><span class="s2">&quot;/vg_effectivesparsitythreshold&quot;</span><span class="o">+</span><span class="s2">&quot; of &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">setThreshold</span><span class="p">))</span>
         <span class="k">else</span><span class="p">:</span>
             <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Unable to find a MinValue or EffectiveSparsityThreshold value from the .vlsv file.&quot;</span><span class="p">)</span>
             <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using a default value of 1.e-16. Override with setThreshold=value.&quot;</span><span class="p">)</span>
             <span class="n">setThreshold</span> <span class="o">=</span> <span class="mf">1.e-16</span>
      <span class="n">ii_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">velocity_cell_values</span> <span class="o">&gt;=</span> <span class="n">setThreshold</span><span class="p">)</span>
      <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Dropping velocity cells under setThreshold value &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">setThreshold</span><span class="p">))</span>

      <span class="n">velocity_cell_ids</span> <span class="o">=</span> <span class="n">velocity_cell_ids</span><span class="p">[</span><span class="n">ii_f</span><span class="p">]</span>
      <span class="n">velocity_cell_values</span> <span class="o">=</span> <span class="n">velocity_cell_values</span><span class="p">[</span><span class="n">ii_f</span><span class="p">]</span>

      <span class="n">velocity_cell_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_velocity_cell_coordinates</span><span class="p">(</span><span class="n">velocity_cell_ids</span><span class="p">,</span> <span class="n">pop</span><span class="p">)</span>
      <span class="n">velocity_cell_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_velocity_cell_indices</span><span class="p">(</span><span class="n">velocity_cell_coordinates</span><span class="p">,</span> <span class="n">pop</span><span class="p">)</span>

      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxmin</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vymin</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vzmin</span><span class="p">])</span>
      <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxmax</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vymax</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vzmax</span><span class="p">])</span>

      
      <span class="n">lowcorner_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">velocity_cell_indices</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">highcorner_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">velocity_cell_indices</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">dv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_velocity_mesh_dv</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>

      <span class="n">lowcorner_coords</span> <span class="o">=</span> <span class="n">vmin</span> <span class="o">+</span> <span class="n">dv</span><span class="o">*</span><span class="n">lowcorner_indices</span>
      <span class="n">highcorner_coords</span> <span class="o">=</span> <span class="n">vmin</span> <span class="o">+</span> <span class="n">dv</span><span class="o">*</span><span class="p">(</span><span class="n">highcorner_indices</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

      <span class="n">shape</span> <span class="o">=</span> <span class="n">highcorner_indices</span><span class="o">+</span><span class="mi">1</span> <span class="o">-</span> <span class="n">lowcorner_indices</span>

      <span class="n">da</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">velocity_cell_coordinates</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lowcorner_coords</span><span class="p">,</span><span class="n">highcorner_coords</span><span class="p">)),</span><span class="n">weights</span><span class="o">=</span><span class="n">velocity_cell_values</span><span class="p">)</span>

      <span class="c1"># </span>
      <span class="k">if</span> <span class="n">regularize</span><span class="p">:</span>
         <span class="n">da</span><span class="p">[</span><span class="n">da</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

      <span class="k">return</span> <span class="n">da</span><span class="p">,</span> <span class="n">edges</span></div>



<div class="viewcode-block" id="VlsvReader.read_velocity_cells">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_velocity_cells">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_velocity_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellid</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read velocity cells from a spatial cell</span>
<span class="sd">      </span>
<span class="sd">      :param cellid: Cell ID of the cell whose velocity cells the function will read</span>
<span class="sd">      :kwarg pop:    Population to read [&quot;proton&quot;]</span>
<span class="sd">      :returns: Map of velocity cell ids (unique for every velocity cell) and corresponding value</span>

<span class="sd">      #Example:</span>

<span class="sd">      example_cellid = 1111</span>

<span class="sd">      velocity_cell_map = vlsvReader.read_velocity_cells(example_cellid)</span>
<span class="sd">      velocity_cell_ids = velocity_cell_map.keys()</span>
<span class="sd">      velocity_cell_values = velocity_cell_map.values()</span>

<span class="sd">      random_index = 4 # Just some index</span>
<span class="sd">      random_velocity_cell_id = velocity_cell_ids[random_index]</span>

<span class="sd">      print (&quot;Velocity cell value at velocity cell id &quot; + str(random_velocity_cell_id) + &quot;: &quot; + str(velocity_cell_map[random_velocity_cell_id]))</span>

<span class="sd">      # Getting the corresponding coordinates might be more useful than having the velocity cell id so:</span>
<span class="sd">      velocity_cell_coordinates = vlsvReader.get_velocity_cell_coordinates(velocity_cell_ids) # Get velocity cell coordinates corresponding to each velocity cell id</span>

<span class="sd">      random_velocity_cell_coordinates = velocity_cell_ids[random_index]</span>
<span class="sd">      print(&quot;Velocity cell value at velocity cell id &quot; + str(random_velocity_cell_id) + &quot;and coordinates &quot; + str(random_velocity_cell_coordinates) + &quot;: &quot; + str(velocity_cell_map[random_velocity_cell_id]))</span>

<span class="sd">      .. seealso:: :func:`read_blocks`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_dict_for_blocks</span><span class="p">:</span> <span class="c1"># old deprecated version, uses dict for blocks data</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__set_cell_offset_and_blocks</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span> 
         <span class="c1"># Check that cells has vspace</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">cellid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">]:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cell(s) does not have velocity distribution&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{}</span>
         <span class="c1"># Navigate to the correct position:</span>
         <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">cellid</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
         <span class="n">num_of_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">cellid</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

      <span class="k">else</span><span class="p">:</span>  <span class="c1"># Uses arrays (much faster to initialize)</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cells_with_blocks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__set_cell_offset_and_blocks_nodict</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span> 
         <span class="c1"># Check that cells has vspace</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="n">cells_with_blocks_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__order_for_cellid_blocks</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">cellid</span><span class="p">]</span>
         <span class="k">except</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cell(s) does not have velocity distribution&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{}</span>
         <span class="c1"># Navigate to the correct position:</span>
         <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell_offsets</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">cells_with_blocks_index</span><span class="p">]</span>
         <span class="n">num_of_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">cells_with_blocks_index</span><span class="p">]</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
         <span class="n">fptr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">fptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span>

      <span class="c1"># Read in avgs and velocity cell ids:</span>
      <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xml_root</span><span class="p">:</span>
         <span class="c1"># Read in avgs</span>
         <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">pop</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;BLOCKVARIABLE&quot;</span><span class="p">):</span>
            <span class="n">vector_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;vectorsize&quot;</span><span class="p">])</span>
            <span class="c1">#array_size = ast.literal_eval(child.attrib[&quot;arraysize&quot;])</span>
            <span class="n">element_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;datasize&quot;</span><span class="p">])</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;datatype&quot;</span><span class="p">]</span>

            <span class="c1"># Navigate to the correct position</span>
            <span class="n">offset_avgs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">vector_size</span> <span class="o">*</span> <span class="n">element_size</span> <span class="o">+</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
            <span class="n">fptr</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset_avgs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
               <span class="n">data_avgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">vector_size</span><span class="o">*</span><span class="n">num_of_blocks</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
               <span class="n">data_avgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">vector_size</span><span class="o">*</span><span class="n">num_of_blocks</span><span class="p">)</span> 
            <span class="n">data_avgs</span> <span class="o">=</span> <span class="n">data_avgs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_of_blocks</span><span class="p">,</span> <span class="n">vector_size</span><span class="p">)</span>
         <span class="c1"># Read in block coordinates:</span>
         <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">pop</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;BLOCKIDS&quot;</span><span class="p">):</span>
            <span class="n">vector_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;vectorsize&quot;</span><span class="p">])</span>
            <span class="c1">#array_size = ast.literal_eval(child.attrib[&quot;arraysize&quot;])</span>
            <span class="n">element_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;datasize&quot;</span><span class="p">])</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;datatype&quot;</span><span class="p">]</span>

            <span class="n">offset_block_ids</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">vector_size</span> <span class="o">*</span> <span class="n">element_size</span> <span class="o">+</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
            <span class="n">fptr</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset_block_ids</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;uint&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
               <span class="n">data_block_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">vector_size</span><span class="o">*</span><span class="n">num_of_blocks</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;uint&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
               <span class="n">data_block_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">vector_size</span><span class="o">*</span><span class="n">num_of_blocks</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Error! Bad data type in blocks! datatype found was &quot;</span><span class="o">+</span><span class="n">datatype</span><span class="p">)</span>

         <span class="k">if</span> <span class="p">(</span><span class="n">pop</span><span class="o">==</span><span class="s2">&quot;avgs&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;BLOCKIDS&quot;</span><span class="p">):</span> <span class="c1"># Old avgs files did not have the name set for BLOCKIDS</span>
            <span class="n">vector_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;vectorsize&quot;</span><span class="p">])</span>
            <span class="c1">#array_size = ast.literal_eval(child.attrib[&quot;arraysize&quot;])</span>
            <span class="n">element_size</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;datasize&quot;</span><span class="p">])</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;datatype&quot;</span><span class="p">]</span>

            <span class="n">offset_block_ids</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="n">vector_size</span> <span class="o">*</span> <span class="n">element_size</span> <span class="o">+</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
            <span class="n">fptr</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset_block_ids</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;uint&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
               <span class="n">data_block_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">vector_size</span><span class="o">*</span><span class="n">num_of_blocks</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">datatype</span> <span class="o">==</span> <span class="s2">&quot;uint&quot;</span> <span class="ow">and</span> <span class="n">element_size</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
               <span class="n">data_block_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">vector_size</span><span class="o">*</span><span class="n">num_of_blocks</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Error! Bad data type in blocks! datatype found was &quot;</span><span class="o">+</span><span class="n">datatype</span><span class="p">)</span>

            <span class="n">data_block_ids</span> <span class="o">=</span> <span class="n">data_block_ids</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_of_blocks</span><span class="p">,</span> <span class="n">vector_size</span><span class="p">)</span>

      <span class="n">fptr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

      <span class="c1"># Check to make sure the sizes match (just some extra debugging)</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_avgs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_block_ids</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;BAD DATA SIZES&quot;</span><span class="p">)</span>
      <span class="c1"># Make a dictionary (hash map) out of velocity cell ids and avgs:</span>
      <span class="n">velocity_cells</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="n">array_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_avgs</span><span class="p">)</span>

      <span class="c1"># Construct velocity cells:</span>
      <span class="n">WID</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_WID</span><span class="p">()</span>
      <span class="n">WID2</span><span class="o">=</span><span class="n">WID</span><span class="o">*</span><span class="n">WID</span>
      <span class="n">WID3</span><span class="o">=</span><span class="n">WID2</span><span class="o">*</span><span class="n">WID</span>
      <span class="n">velocity_cell_ids</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">kv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">WID</span><span class="p">):</span>
         <span class="k">for</span> <span class="n">jv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">WID</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">WID</span><span class="p">):</span>
               <span class="n">velocity_cell_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kv</span><span class="o">*</span><span class="n">WID2</span> <span class="o">+</span> <span class="n">jv</span><span class="o">*</span><span class="n">WID</span> <span class="o">+</span> <span class="n">iv</span><span class="p">)</span>

      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array_size</span><span class="p">):</span>
         <span class="n">velocity_block_id</span> <span class="o">=</span> <span class="n">data_block_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
         <span class="n">avgIndex</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="n">avgs</span> <span class="o">=</span> <span class="n">data_avgs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

         <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">velocity_cell_ids</span> <span class="o">+</span> <span class="n">WID3</span><span class="o">*</span><span class="n">velocity_block_id</span><span class="p">:</span>
            <span class="n">velocity_cells</span><span class="p">[(</span><span class="nb">int</span><span class="p">)(</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">avgs</span><span class="p">[</span><span class="n">avgIndex</span><span class="p">]</span>
            <span class="n">avgIndex</span> <span class="o">=</span> <span class="n">avgIndex</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">return</span> <span class="n">velocity_cells</span></div>


<div class="viewcode-block" id="VlsvReader.get_spatial_mesh_size">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_spatial_mesh_size">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_spatial_mesh_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read spatial mesh size</span>
<span class="sd">      </span>
<span class="sd">      :returns: Size of mesh in number of blocks, array with three elements</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__xcells</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ycells</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__zcells</span><span class="p">])</span></div>


<div class="viewcode-block" id="VlsvReader.get_spatial_block_size">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_spatial_block_size">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_spatial_block_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read spatial mesh block size</span>
<span class="sd">      </span>
<span class="sd">      :returns: Size of block in number of cells, array with three elements</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__xblock_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__yblock_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__zblock_size</span><span class="p">])</span></div>


<div class="viewcode-block" id="VlsvReader.get_spatial_mesh_extent">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_spatial_mesh_extent">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_spatial_mesh_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read spatial mesh extent</span>
<span class="sd">      </span>
<span class="sd">      :returns: Maximum and minimum coordinates of the mesh, [xmin, ymin, zmin, xmax, ymax, zmax]</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__zmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ymax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__zmax</span><span class="p">])</span></div>


<div class="viewcode-block" id="VlsvReader.get_fsgrid_mesh_size">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_fsgrid_mesh_size">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_fsgrid_mesh_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read fsgrid mesh size</span>
<span class="sd">      </span>
<span class="sd">      :returns: Size of mesh in number of cells, array with three elements</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="c1"># Get fsgrid domain size (this can differ from vlasov grid size if refined)</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_BBOX&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;fsgrid&quot;</span><span class="p">)</span>
         <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
      <span class="k">except</span><span class="p">:</span>
         <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_BBOX&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;SpatialGrid&quot;</span><span class="p">)</span>
         <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_refinement_level</span><span class="p">()</span></div>


<div class="viewcode-block" id="VlsvReader.get_fsgrid_mesh_extent">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_fsgrid_mesh_extent">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_fsgrid_mesh_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read fsgrid mesh extent</span>
<span class="sd">      </span>
<span class="sd">      :returns: Maximum and minimum coordinates of the mesh, [xmin, ymin, zmin, xmax, ymax, zmax]</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__zmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__xmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ymax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__zmax</span><span class="p">])</span></div>


<div class="viewcode-block" id="VlsvReader.get_fsgrid_cell_size">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_fsgrid_cell_size">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_fsgrid_cell_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read fsgrid cell size</span>
<span class="sd">      </span>
<span class="sd">      :returns: Maximum and minimum coordinates of the mesh, [dx, dy, dz]</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_size</span><span class="p">()</span>
      <span class="n">ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_extent</span><span class="p">()</span>
      <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">-</span><span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">ext</span><span class="o">/</span><span class="n">size</span></div>


<div class="viewcode-block" id="VlsvReader.get_fsgrid_indices">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_fsgrid_indices">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_fsgrid_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Convert spatial coordinates coords to an index array [xi, yi, zi] for fsgrid</span>

<span class="sd">      :returns 3-tuple of integers [xi, yi, zi] corresponding to fsgrid cell containing coords (low-inclusive)</span>
<span class="sd">      Example:</span>
<span class="sd">      ii = f.get_fsgrid_mesh_extent(coords)</span>
<span class="sd">      fsvar_at_coords = fsvar_array.item(ii)</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_extent</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
      <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_cell_size</span><span class="p">()</span>
      <span class="n">r0</span> <span class="o">=</span> <span class="n">coords</span><span class="o">-</span><span class="n">lower</span>
      <span class="n">ri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">r0</span><span class="o">/</span><span class="n">dx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
      <span class="n">sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_mesh_size</span><span class="p">()</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ri</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ri</span><span class="o">&gt;</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
         <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;get_fsgrid_indices: Resulting index out of bounds, returning None&quot;</span><span class="p">)</span>
         <span class="k">return</span> <span class="kc">None</span>
      <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span></div>


<div class="viewcode-block" id="VlsvReader.get_fsgrid_slice_indices">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_fsgrid_slice_indices">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_fsgrid_slice_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Get indices for a subarray of an fsgrid variable, in the cuboid from lower to upper.</span>
<span class="sd">      This is meant for mapping a set of fsgrid cells to a given SpatialGrid cell.</span>
<span class="sd">      Shifts the corners (lower, upper) by dx_fsgrid*eps inward, if direct low-inclusive behaviour</span>
<span class="sd">      is required, set kwarg eps = 0.</span>


<span class="sd">      :returns two 3-tuples of integers.</span>
<span class="sd">      Example:</span>
<span class="sd">      ii = f.get_fsgrid_mesh_extent(coords)</span>
<span class="sd">      fsvar_at_coords = fsvar_array.item(ii)</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_cell_size</span><span class="p">()</span>
      <span class="n">eps</span> <span class="o">=</span> <span class="n">dx</span><span class="o">*</span><span class="n">eps</span>
      <span class="n">loweri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_indices</span><span class="p">(</span><span class="n">lower</span><span class="o">+</span><span class="n">eps</span><span class="p">)</span>
      <span class="n">upperi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fsgrid_indices</span><span class="p">(</span><span class="n">upper</span><span class="o">-</span><span class="n">eps</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">loweri</span><span class="p">,</span> <span class="n">upperi</span></div>

      

<div class="viewcode-block" id="VlsvReader.get_velocity_mesh_size">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_velocity_mesh_size">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_velocity_mesh_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read velocity mesh size</span>
<span class="sd">      </span>
<span class="sd">      :returns: Size of mesh in number of blocks, array with three elements</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblocks</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblocks</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vzblocks</span><span class="p">])</span></div>


<div class="viewcode-block" id="VlsvReader.get_velocity_block_size">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_velocity_block_size">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_velocity_block_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read velocity mesh block size</span>
<span class="sd">      </span>
<span class="sd">      :returns: Size of block in number of cells, array with three elements</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxblock_size</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vyblock_size</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vzblock_size</span><span class="p">])</span></div>


<div class="viewcode-block" id="VlsvReader.get_velocity_mesh_extent">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_velocity_mesh_extent">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_velocity_mesh_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read velocity mesh extent</span>
<span class="sd">      </span>
<span class="sd">      :returns: Maximum and minimum coordinates of the mesh, [vxmin, vymin, vzmin, vxmax, vymax, vzmax]</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__vxmin</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vymin</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vzmin</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vxmax</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vymax</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__vzmax</span><span class="p">])</span></div>


<div class="viewcode-block" id="VlsvReader.get_velocity_mesh_dv">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_velocity_mesh_dv">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_velocity_mesh_dv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read velocity mesh cell size</span>
<span class="sd">      </span>
<span class="sd">      :returns: Velocity mesh cell size, array with three elements [dvx, dvy, dvz]</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">popmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">popmesh</span><span class="o">.</span><span class="n">__dvx</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvy</span><span class="p">,</span> <span class="n">popmesh</span><span class="o">.</span><span class="n">__dvz</span><span class="p">])</span></div>


<div class="viewcode-block" id="VlsvReader.get_ionosphere_mesh_size">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_ionosphere_mesh_size">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_ionosphere_mesh_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read size of the ionosphere mesh, if there is one.</span>

<span class="sd">      :returns: Size of the mesh in number of nodes and elements, array with two elements</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="n">domainsizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_DOMAIN_SIZES&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;ionosphere&quot;</span><span class="p">)</span>
         <span class="k">return</span> <span class="p">[</span><span class="n">domainsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">domainsizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
      <span class="k">except</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error: Failed to read ionosphere mesh size. Are you reading from a file without ionosphere?&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="VlsvReader.get_ionosphere_node_coords">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_ionosphere_node_coords">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_ionosphere_node_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read ionosphere node coordinates (in cartesian GSM coordinate system).</span>

<span class="sd">      :returns: [x,y,z] array of ionosphere node coordinates (in meters)</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH_NODE_CRDS&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="s2">&quot;ionosphere&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
         <span class="k">return</span> <span class="n">coords</span>
      <span class="k">except</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error: Failed to read ionosphere mesh coordinates. Are you reading from a file without ionosphere?&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="VlsvReader.get_ionosphere_latlon_coords">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_ionosphere_latlon_coords">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_ionosphere_latlon_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read ionosphere node coordinates (in magnetic longitude / latitude)</span>

<span class="sd">      :returns: [lat,lon] array of ionosphere node coordinates</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ionosphere_node_coords</span><span class="p">()</span>
      <span class="n">latlon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">])</span>
      <span class="n">latlon</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mf">6471e3</span><span class="p">)</span>   <span class="c1"># Note, ionosphere height is R_E + 100km</span>
      <span class="n">latlon</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">return</span> <span class="n">latlon</span></div>


<div class="viewcode-block" id="VlsvReader.get_ionosphere_element_corners">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_ionosphere_element_corners">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_ionosphere_element_corners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read ionosphere mesh element corners</span>

<span class="sd">      :returns: [c1,c2,c3] array of ionosphere mesh node indices (starting from 0)</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="n">meshdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s2">&quot;MESH&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ionosphere&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
         <span class="c1"># Elements in meshdata are:</span>
         <span class="c1"># - vlsv::celltype::TRIANGLE (&quot;this is a triangle&quot;)</span>
         <span class="c1"># - 3                        (&quot;it has three corners&quot;)</span>
         <span class="c1"># - Corner index 1</span>
         <span class="c1"># - Corner index 2</span>
         <span class="c1"># - Corner index 3</span>
         <span class="k">return</span> <span class="n">meshdata</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
      <span class="k">except</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error: Failed to read ionosphere mesh elements. Are you reading from a file without ionosphere?&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="VlsvReader.get_ionosphere_mesh_area">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_ionosphere_mesh_area">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_ionosphere_mesh_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read areas of ionosphere elements (triangular mesh)</span>

<span class="sd">      :returns: 1D array, areas of the triangular elements [m^2]</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ionosphere_node_coords</span><span class="p">()</span>       <span class="c1"># nodes: shape (n_nodes, 3) vertices</span>
      <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ionosphere_element_corners</span><span class="p">()</span>   <span class="c1"># corners of elements: indices integers 0-(n_nodes-1), shape (n_elements, 3)</span>
      <span class="n">p</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">c</span><span class="p">,:]</span>                               <span class="c1"># shape(n_elements, 3, 3)   1st index is the element, 2nd index is triangle corners, 3rd index is x-y-z position</span>
      <span class="n">r1</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
      <span class="n">r2</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
      <span class="n">areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
      <span class="c1"># checked: sum of triangle areas is near the expected area 4*pi*R^2 for a sphere:</span>
      <span class="c1"># ( np.sum(areas) - (np.pi * 4 ) * (R_EARTH + 100000.)**2 ) / np.sum(areas) ~ 1</span>
      <span class="k">return</span> <span class="n">areas</span></div>


<div class="viewcode-block" id="VlsvReader.get_ionosphere_element_coords">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_ionosphere_element_coords">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_ionosphere_element_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read coordinates of ionosphere elements (triangle barycenters)</span>

<span class="sd">      :returns: [x, y, z] array of ionosphere element barycenter coordinates (in meters).</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ionosphere_node_coords</span><span class="p">()</span>          <span class="c1"># Nodes, shape (n_nodes, 3)</span>
      <span class="n">ec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ionosphere_element_corners</span><span class="p">()</span>     <span class="c1"># Element corners, shape (n_elements, 3)</span>
      <span class="n">ig_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ec</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ig_r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
         <span class="n">ig_r</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">ec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="n">ec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="n">ec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">:])</span> <span class="o">/</span> <span class="mi">3</span>  <span class="c1">#barycenter, aka centroid</span>
      <span class="k">return</span> <span class="n">ig_r</span></div>


<div class="viewcode-block" id="VlsvReader.read_ionosphere_node_variable_at_elements">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_ionosphere_node_variable_at_elements">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_ionosphere_node_variable_at_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Interpolate an ionospheric node variavle to the element barycenters</span>

<span class="sd">      :param varname: string, specifying variable (or data reducer) defined at ionosphere nodes</span>
<span class="sd">      :returns: specified variable interpolated to the elements&#39; barycenters</span>

<span class="sd">        note: linear barycentric interpolation is just the sum of 3 corner values divided by 3!</span>

<span class="sd">        TODO: check behavior for var.ndim&gt;1</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_variable</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ionosphere_element_corners</span><span class="p">()</span>              <span class="c1"># (n_elements, 3) node indices</span>
      <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.</span></div>


<div class="viewcode-block" id="VlsvReader.read_blocks">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.read_blocks">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">read_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cellid</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read raw block data from the open file and return the data along with block ids</span>
<span class="sd">      </span>
<span class="sd">      :param cellid: Cell ID of the cell whose velocity blocks are read</span>
<span class="sd">      :returns: A numpy array with block ids and data eg [array([2, 5, 6, 234, 21]), array([1.0e-8, 2.1e-8, 2.1e-8, 0, 4.0e-8])]</span>

<span class="sd">      .. seealso:: :func:`read_velocity_cells`</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="c1"># Uses new format</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_blocks</span><span class="p">(</span><span class="n">cellid</span><span class="p">,</span><span class="n">pop</span><span class="p">)</span></div>


<div class="viewcode-block" id="VlsvReader.get_precipitation_centre_energy">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.get_precipitation_centre_energy">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">get_precipitation_centre_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="s2">&quot;proton&quot;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Read precipitation energy bins</span>

<span class="sd">      :returns: Array of centre energies</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__popmesh</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span><span class="o">.</span><span class="n">__precipitation_centre_energy</span></div>


<div class="viewcode-block" id="VlsvReader.optimize_open_file">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.optimize_open_file">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">optimize_open_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Opens the vlsv file for reading</span>
<span class="sd">         Files are opened and closed automatically upon reading and in the case of reading multiple times it will help to keep the file open with this command</span>

<span class="sd">         .. code-block: python</span>

<span class="sd">            #Example usage:</span>
<span class="sd">            variables = []</span>
<span class="sd">            vlsvReader.optimize_open_file()</span>
<span class="sd">            for i in range(1000):</span>
<span class="sd">               variables.append(vlsvReader.read_variable(&quot;rho&quot;, cellids=i))</span>
<span class="sd">            vlsvReader.optimize_close_file()</span>

<span class="sd">         .. note:: This should only be used for optimization purposes.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">,</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="VlsvReader.optimize_close_file">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.optimize_close_file">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">optimize_close_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39;Closes the vlsv file</span>
<span class="sd">         Files are opened and closed automatically upon reading and in the case of reading multiple times it will help to keep the file open with this command</span>

<span class="sd">         .. code-block: python</span>

<span class="sd">            # Example usage:</span>
<span class="sd">            variables = []</span>
<span class="sd">            vlsvReader.optimize_open_file()</span>
<span class="sd">            for i in range(1000):</span>
<span class="sd">               variables.append(vlsvReader.read_variable(&quot;rho&quot;, cellids=i))</span>
<span class="sd">            vlsvReader.optimize_close_file()</span>

<span class="sd">         .. note:: This should only be used for optimization purposes.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
         <span class="k">return</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__fptr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
         <span class="k">return</span></div>


<div class="viewcode-block" id="VlsvReader.optimize_clear_fileindex_for_cellid_blocks">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.optimize_clear_fileindex_for_cellid_blocks">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">optimize_clear_fileindex_for_cellid_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Clears a private variable containing number of blocks and offsets for particular cell ids</span>

<span class="sd">         .. code-block: python</span>

<span class="sd">             # Example usage:</span>
<span class="sd">             vlsvReaders = []</span>
<span class="sd">             # Open a list of vlsv files</span>
<span class="sd">             for i in range(1000):</span>
<span class="sd">                vlsvReaders.append( VlsvReader(&quot;test&quot; + str(i) + &quot;.vlsv&quot;) )</span>
<span class="sd">             # Go through vlsv readers and print info:</span>
<span class="sd">             for vlsvReader in vlsvReaders:</span>
<span class="sd">                # Print something from the file on the screen</span>
<span class="sd">                print( vlsvReader.read_blocks( cellid= 5021 )) # Stores info into a private variable</span>
<span class="sd">                # Upon reading from vlsvReader a private variable that contains info on cells that have blocks has been saved -- now clear it to save memory</span>
<span class="sd">                vlsvReader.optimize_clear_fileindex_for_cellid_blocks()</span>

<span class="sd">         .. note:: This should only be used for optimization purposes.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid_blocks</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__cells_with_blocks</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__blocks_per_cell_offsets</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__order_for_cellid_blocks</span> <span class="o">=</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="VlsvReader.optimize_clear_fileindex_for_cellid">
<a class="viewcode-back" href="../../../../vlsvfile/#analysator.vlsvfile.VlsvReader.optimize_clear_fileindex_for_cellid">[docs]</a>
   <span class="k">def</span><span class="w"> </span><span class="nf">optimize_clear_fileindex_for_cellid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&#39;&#39;&#39; Clears a private variable containing cell ids and their locations</span>

<span class="sd">         .. code-block: python</span>

<span class="sd">             # Example usage:</span>
<span class="sd">             vlsvReaders = []</span>
<span class="sd">             # Open a list of vlsv files</span>
<span class="sd">             for i in range(1000):</span>
<span class="sd">                vlsvReaders.append( VlsvReader(&quot;test&quot; + str(i) + &quot;.vlsv&quot;) )</span>
<span class="sd">             # Go through vlsv readers and logging.info info:</span>
<span class="sd">             for vlsvReader in vlsvReaders:</span>
<span class="sd">                # Print something from the file on the screen</span>
<span class="sd">                logging.info vlsvReader.read_variable(&quot;B&quot;, cellids=2) # Stores info into a private variable</span>
<span class="sd">                # Upon reading from vlsvReader a private variable that contains info on cells that have blocks has been saved -- now clear it to save memory</span>
<span class="sd">                vlsvReader.optimize_clear_fileindex_for_cellid()</span>

<span class="sd">         .. note:: This should only be used for optimization purposes.</span>
<span class="sd">      &#39;&#39;&#39;</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">__fileindex_for_cellid</span> <span class="o">=</span> <span class="p">{}</span></div>
</div>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, University of Helsinki.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>